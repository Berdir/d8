<?php
/**
 * @file
 * Install, update and uninstall functions for the Comment module.
 */
use Drupal\node\Plugin\Core\Entity\Node;
use Drupal\comment\Plugin\Core\Entity\Comment;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\CoreBundle;

/**
 * Implements hook_uninstall().
 */
function comment_uninstall() {
  // Delete comment_body field.
  field_delete_field('comment_body');

  // Remove variables.
  variable_del('comment_block_count');
  // We cannot use comment_get_comment_fields because comment.module is
  // disabled.
  $comment_fields = array_filter(field_info_fields(), function ($value) {
    if ($value['type']  == 'comment') {
      return TRUE;
    }
  });
  foreach ($comment_fields as $field_name => $field) {
    field_attach_delete_bundle('comment', $field_name);
  }

  // Remove states.
  state()->delete('comment.node_comment_statistics_scale');
}

/**
 * Implements hook_enable().
 */
function comment_enable() {
  $comment_fields = comment_get_comment_fields();
  $entity_info = entity_get_info();
  foreach ($comment_fields as $field_name => $info) {
    foreach ($info['bundles'] as $entity_type => $bundles) {
      foreach ($bundles as $bundle) {
        $entity_detail = $entity_info[$entity_type];
        if (!empty($entity_detail['base_table']) &&
            !empty($entity_detail['entity_keys']['id'])) {
          $table = $entity_detail['base_table'];
          $schema = drupal_get_schema($table);
          // Insert records into the comment_entity_statistics for entities that
          // are missing.
          $query = db_select($table, 'e');
          // Filter by bundle.
          $query->condition($entity_detail['entity_keys']['bundle'], $bundle);
          $query->leftJoin('comment_entity_statistics', 'ces', 'ces.entity_id = e.' . $entity_detail['entity_keys']['id'] . " AND ces.entity_type = '$entity_type'");
          if (!empty($schema[$table]['fields']['created'])) {
            $query->addField('e', 'created', 'last_comment_timestamp');
          }
          else {
            // No created field for this entity type, default to now.
            $query->addExpression(REQUEST_TIME, 'last_comment_timestamp');
          }
          if (!empty($schema[$table]['fields']['uid'])) {
            $query->addField('e', 'uid', 'last_comment_uid');
          }
          else {
            // No uid field for this entity type, default to anonymous.
            $query->addExpression(0, 'last_comment_uid');
          }
          $query->addField('e', $entity_detail['entity_keys']['id'], 'entity_id');
          $query->addExpression("'$entity_type'", 'entity_type');
          $query->addExpression("'$field_name'", 'field_name');
          $query->addExpression('0', 'comment_count');
          $query->addExpression('NULL', 'last_comment_name');
          $query->isNull('ces.comment_count');

          db_insert('comment_entity_statistics')
            ->from($query)
            ->execute();
        }
      }
    }
  }
  // Set default value of comment.maintain_entity_statistics.
  state()->set('comment.maintain_entity_statistics', TRUE);
}

/**
 * Implements hook_schema().
 */
function comment_schema() {
  $schema['comment'] = array(
    'description' => 'Stores comments and associated data.',
    'fields' => array(
      'cid' => array(
        'type' => 'serial',
        'not null' => TRUE,
        'description' => 'Primary Key: Unique comment ID.',
      ),
      'uuid' => array(
        'description' => 'Unique Key: Universally unique identifier for this entity.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => FALSE,
      ),
      'pid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The {comment}.cid to which this comment is a reply. If set to 0, this comment is not a reply to an existing comment.',
      ),
      'entity_id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The entity_id to which this comment is a reply.',
      ),
      'entity_type' => array(
        'type' => 'varchar',
        'not null' => TRUE,
        'default' => 'node',
        'length' => 255,
        'description' => 'The entity_type to which this comment is a reply.',
      ),
      'field_name' => array(
        'type' => 'varchar',
        'not null' => TRUE,
        'default' => 'comment',
        'length' => 255,
        'description' => 'The field_name through which this comment was added.',
      ),
      'uid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The {users}.uid who authored the comment. If set to 0, this comment was created by an anonymous user.',
      ),
      'subject' => array(
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => '',
        'description' => 'The comment title.',
      ),
      'hostname' => array(
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '',
        'description' => "The author's host name.",
      ),
      'created' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The time that the comment was created, as a Unix timestamp.',
      ),
      'changed' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The time that the comment was last edited, as a Unix timestamp.',
      ),
      'status' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 1,
        'size' => 'tiny',
        'description' => 'The published status of a comment. (0 = Not Published, 1 = Published)',
      ),
      'thread' => array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'description' => "The alphadecimal representation of the comment's place in a thread, consisting of a base 36 string prefixed by an integer indicating its length.",
      ),
      'name' => array(
        'type' => 'varchar',
        'length' => 60,
        'not null' => FALSE,
        'description' => "The comment author's name. Uses {users}.name if the user is logged in, otherwise uses the value typed into the comment form.",
      ),
      'mail' => array(
        'type' => 'varchar',
        'length' => 64,
        'not null' => FALSE,
        'description' => "The comment author's e-mail address from the comment form, if user is anonymous, and the 'Anonymous users may/must leave their contact information' setting is turned on.",
      ),
      'homepage' => array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE,
        'description' => "The comment author's home page address from the comment form, if user is anonymous, and the 'Anonymous users may/must leave their contact information' setting is turned on.",
      ),
      'langcode' => array(
        'description' => 'The {language}.langcode of this comment.',
        'type' => 'varchar',
        'length' => 12,
        'not null' => TRUE,
        'default' => '',
      ),
    ),
    'indexes' => array(
      'comment_status_pid' => array('pid', 'status'),
      'comment_num_new' => array(
        'entity_id',
        'entity_type',
        'field_name',
        'status',
        'created',
        'cid',
        'thread'
      ),
      'comment_uid' => array('uid'),
      'comment_entity_langcode' => array(
        'entity_id',
        'entity_type',
        'field_name',
        'langcode'
      ),
      'comment_created' => array('created'),
    ),
    'primary key' => array('cid'),
    'unique keys' => array(
      'uuid' => array('uuid'),
    ),
    'foreign keys' => array(
      'comment_author' => array(
        'table' => 'users',
        'columns' => array('uid' => 'uid'),
      ),
    ),
  );

  $schema['comment_entity_statistics'] = array(
    'description' => 'Maintains statistics of entity and comments posts to show "new" and "updated" flags.',
    'fields' => array(
      'entity_id' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The entity_id for which the statistics are compiled.',
      ),
      'entity_type' => array(
        'type' => 'varchar',
        'not null' => TRUE,
        'default' => 'node',
        'length' => 255,
        'description' => 'The entity_type to which this comment is a reply.',
      ),
      'field_name' => array(
        'type' => 'varchar',
        'not null' => TRUE,
        'default' => 'comment',
        'length' => 255,
        'description' => 'The field_name through which this comment was added.',
      ),
      'cid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The {comment}.cid of the last comment.',
      ),
      'last_comment_timestamp' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The Unix timestamp of the last comment that was posted within this node, from {comment}.changed.',
      ),
      'last_comment_name' => array(
        'type' => 'varchar',
        'length' => 60,
        'not null' => FALSE,
        'description' => 'The name of the latest author to post a comment on this node, from {comment}.name.',
      ),
      'last_comment_uid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The user ID of the latest author to post a comment on this node, from {comment}.uid.',
      ),
      'comment_count' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The total number of comments on this node.',
      ),
    ),
    'primary key' => array('entity_id', 'entity_type', 'field_name'),
    'indexes' => array(
      'node_comment_timestamp' => array('last_comment_timestamp'),
      'comment_count' => array('comment_count'),
      'last_comment_uid' => array('last_comment_uid'),
    ),
    'foreign keys' => array(
      'last_comment_author' => array(
        'table' => 'users',
        'columns' => array(
          'last_comment_uid' => 'uid',
        ),
      ),
    ),
  );

  return $schema;
}

/**
 * Implements hook_field_schema().
 */
function comment_field_schema($field) {
  $columns = array();
  if ($field['type'] == 'comment') {
    $columns += array(
      'comment' => array(
        'description' => 'Whether comments are allowed on this entity: 0 = no, 1 = closed (read only), 2 = open (read/write).',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
    );
  }
  return array(
    'columns' => $columns,
  );
}

/**
 * @addtogroup updates-7.x-to-8.x
 * @{
 */

/**
 * Renames {comment}.language to {comment}.langcode.
 */
function comment_update_8000() {
  db_drop_index('comment', 'comment_nid_language');
  $langcode_spec = array(
    'type' => 'varchar',
    'length' => 12,
    'not null' => TRUE,
    'default' => '',
    'description' => "Language code, e.g. 'de' or 'en-US'.",
  );
  db_change_field('comment', 'language', 'langcode', $langcode_spec);
  db_add_index('comment', 'comment_nid_langcode', array('nid', 'langcode'));
}

/**
 * Create a UUID column for comments.
 */
function comment_update_8001() {
  $spec = array(
    'description' => 'Unique Key: Universally unique identifier for this entity.',
    'type' => 'varchar',
    'length' => 128,
    'not null' => FALSE,
  );
  $keys = array(
    'unique keys' => array(
      'uuid' => array('uuid'),
    ),
  );
  // Account for sites having the contributed UUID module installed.
  if (db_field_exists('comment', 'uuid')) {
    db_change_field('comment', 'uuid', 'uuid', $spec, $keys);
  }
  else {
    db_add_field('comment', 'uuid', $spec, $keys);
  }
}

/**
 * Make *id fields unsigned.
 */
function comment_update_8002() {
  db_drop_index('comment', 'comment_num_new');
  db_drop_index('comment', 'comment_nid_langcode');
  db_change_field('comment', 'nid', 'nid',
    array(
      'type' => 'int',
      'unsigned' => TRUE,
      'not null' => TRUE,
      'default' => 0,
      'description' => 'The {node}.nid to which this comment is a reply.',
    ),
    array('indexes' => array(
      'comment_num_new' => array('nid', 'status', 'created', 'cid', 'thread'),
      'comment_nid_langcode' => array('nid', 'langcode'),
    ))
  );
  db_drop_index('comment', 'comment_uid');
  db_change_field('comment', 'uid', 'uid',
    array(
      'type' => 'int',
      'unsigned' => TRUE,
      'not null' => TRUE,
      'default' => 0,
      'description' => 'The {users}.uid who authored the comment. If set to 0, this comment was created by an anonymous user.',
    ),
    array('indexes' => array(
      'comment_uid' => array('uid'),
    ))
  );

  db_drop_index('node_comment_statistics', 'last_comment_uid');
  db_change_field('node_comment_statistics', 'last_comment_uid', 'last_comment_uid',
    array(
      'type' => 'int',
      'unsigned' => TRUE,
      'not null' => TRUE,
      'default' => 0,
      'description' => 'The user ID of the latest author to post a comment on this node, from {comment}.uid.',
    ),
    array('indexes' => array(
      'last_comment_uid' => array('last_comment_uid'),
    ))
  );
}

/**
 * Generate a UUID for all comments.
 */
function comment_update_8003(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['last'] = 0;
    $sandbox['max'] = db_query('SELECT COUNT(cid) FROM {comment} WHERE uuid IS NULL')->fetchField();
  }

  $cids = db_query_range('SELECT cid FROM {comment} WHERE cid > :cid AND uuid IS NULL ORDER BY cid ASC', 0, 10, array(':cid' => $sandbox['last']))->fetchCol();
  update_add_uuids($sandbox, 'comment', 'cid', $cids);

  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress'] / $sandbox['max']);
}

/**
 * Convert variables to state.
 */
function comment_update_8004() {
  update_variables_to_state(array(
    'node_cron_comments_scale' => 'comment.node_comment_statistics_scale',
  ));
}

/**
 * Updates the comment_node_statistics and comment tables to new structure.
 */
function comment_update_8005(&$sandbox) {
  // Remove the comment_node foreign key.
  db_drop_index('comment', 'comment_node');
  // Remove the comment_nid_langcode index.
  db_drop_index('comment', 'comment_nid_langcode');
  // Add the entity_type and field_name columns to comment.
  db_add_field('comment', 'entity_type', array(
    'type' => 'varchar',
    'not null' => TRUE,
    'default' => 'node',
    'length' => 255,
    'description' => 'The entity_type to which this comment is a reply.',
  ));
  db_add_field('comment', 'field_name', array(
    'type' => 'varchar',
    'not null' => TRUE,
    'default' => 'comment',
    'length' => 255,
    'description' => 'The field_name to which this comment is a reply.',
  ));
  // Rename the nid column to entity_id.
  db_change_field('comment', 'nid', 'entity_id', array(
    'type' => 'int',
    'not null' => TRUE,
    'default' => 0,
    'description' => 'The entity_id to which this comment is a reply.',
  ));
  // Add the comment_entity_langcode index.
  db_add_index('comment', 'comment_entity_langcode', array(
    'entity_id',
    'entity_type',
    'field_name',
    'langcode'
  ));
  // Rename node_comment_statistics to comment_entity_statistics.
  db_rename_table('node_comment_statistics', 'comment_entity_statistics');
  // Remove the statistics_node foreign key from entity_comment_statistics.
  // Add the entity_type and field_name columns to comment_entity_statistics.
  db_add_field('comment_entity_statistics', 'entity_type', array(
    'type' => 'varchar',
    'not null' => TRUE,
    'default' => 'node',
    'length' => 255,
    'description' => 'The entity_type to which this comment is a reply.',
  ));
  db_add_field('comment_entity_statistics', 'field_name', array(
    'type' => 'varchar',
    'not null' => TRUE,
    'default' => 'comment',
    'length' => 255,
    'description' => 'The field_name to which this comment is a reply.',
  ));
  // Rename the nid column in entity_comment_statistics to entity_id.
  db_change_field('comment_entity_statistics', 'nid', 'entity_id', array(
    'type' => 'int',
    'not null' => TRUE,
    'default' => 0,
    'description' => 'The entity_id to which this comment is a reply.',
  ));
  $t = get_t();
  return $t('Updated database to reflect new comment structure');
}

/**
 * Adds new field_api fields.
 */
function comment_update_8006(&$sandbox) {
  // Loop over defined node_types.
  $node_types = array_keys(_update_7000_node_get_types());
  foreach ($node_types as $node_type) {
    // Add a default comment field for existing node comments.
    $field = array(
      'cardinality' => '1',
      // We need one per node type to match the existing bundles.
      'field_name' => 'comment_node_' . $node_type,
      'module' => 'comment',
      'settings' => array(),
      'translatable' => '0',
      'type' => 'comment',
    );
    // Make sure field doesn't already exist.
    if (!_update_7000_field_read_fields(array('field_name' => 'comment_node_' . $node_type))) {
      // Create the field.
      _update_7000_field_create_field($field);
    }
    // Add the comment field, setting the instance settings to match those for the
    // give node_type.
    $instance = array(
      'bundle' => $node_type,
      'default_value' => array(
        0 => array(
          'comment' => variable_get('comment_' . $node_type, 0),
        )
      ),
      'deleted' => '0',
      'description' => '',
      'display' => array(
        'default' => array(
          'label' => 'above',
          'module' => 'comment',
          'settings' => array(),
          'type' => 'comment_default',
          'weight' => '1',
        ),
        'rss' => array(
          'type' => 'hidden',
          'label' => 'hidden',
        ),
        'teaser' => array(
          'type' => 'hidden',
          'label' => 'hidden',
        ),
        'search_index' => array(
          'type' => 'hidden',
          'label' => 'hidden',
        ),
        'search_result' => array(
          'type' => 'hidden',
          'label' => 'hidden',
        ),
      ),
      'entity_type' => 'node',
      'field_name' => 'comment_node_' . $node_type,
      'label' => 'Comment settings',
      'required' => 1,
      'settings' => array(
        'comment' => array(
          'comment' => variable_get('comment_' . $node_type, 0),
          'comment_default_mode' => variable_get('comment_default_mode_' . $node_type, 1),
          'comment_default_per_page' => variable_get('comment_default_per_page_' . $node_type, 50),
          'comment_anonymous' => variable_get('comment_anonymous_' . $node_type, 0),
          'comment_subject_field' => variable_get('comment_subject_field_' . $node_type, 1),
          'comment_form_location' => variable_get('comment_form_location_' . $node_type, 1),
          'comment_preview' => variable_get('comment_preview_' . $node_type, 1)
        )
      ),
      'widget' => array(
        'active' => 0,
        'module' => 'comment',
        'settings' => array(),
        'type' => 'comment_default',
        'weight' => '50',
      ),
    );
    _update_7000_field_create_instance($field, $instance);
    // Rename the comment bundle for this node type.
    // Clean up old variables.
    variable_del('comment_' . $node_type);
    variable_del('comment_default_mode_' . $node_type);
    variable_del('comment_default_per_page_' . $node_type);
    variable_del('comment_anonymous_' . $node_type);
    variable_del('comment_subject_field_' . $node_type);
    variable_del('comment_form_location_' . $node_type);
    variable_del('comment_preview_' . $node_type);
  }
  $t = get_t();
  return $t('Created required fields for each comment bundle');
}

/**
 * Updates existing values.
 */
function comment_update_8007(&$sandbox) {

  $types = array_keys(_update_7000_node_get_types());
   // Load each node type in batch and initialize field values for comment field.
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['current_nid'] = 0;
    // We track all node types here.
    $sandbox['node_types'] = $types;
    // We start with this node type.
    $sandbox['node_type'] = array_shift($sandbox['node_types']);
    $sandbox['#finished'] = 1;
    $sandbox['max'] = db_query('SELECT COUNT(DISTINCT nid) FROM {node}')->fetchField();
  }

  // Set the initial values of comment fields for existing nodes. Note that
  // contrib modules will need to handle the upgrade path on their own, as
  // they are disabled during core upgrade.

  // Node table will always exist up until here because in 7.x comment
  // depends on node.
  $nodes = db_select('node', 'n')
    ->fields('n', array('nid', 'comment', 'vid', 'langcode'))
    ->condition('type', $sandbox['node_type'])
    ->condition('nid', $sandbox['current_nid'], '>')
    ->range(0, 50)
    ->orderBy('nid', 'ASC')
    ->execute()
    ->fetchAllAssoc('nid');

  if (count($nodes) > 0) {
    $insert = db_insert('field_data_comment_node_' . $sandbox['node_type'])->
      fields(array(
        'entity_type',
        'bundle',
        'entity_id',
        'revision_id',
        'langcode',
        'delta',
        'comment_node_' . $sandbox['node_type'] . '_comment',
      ));
      $revision = db_insert('field_revision_comment_node_' . $sandbox['node_type'])->
      fields(array(
        'entity_type',
        'bundle',
        'entity_id',
        'revision_id',
        'langcode',
        'delta',
        'comment_node_' . $sandbox['node_type'] . '_comment',
      ));

    // Update the field name to match the node type.
    db_update('comment')->fields(
      array('field_name' => 'comment_node_' . $sandbox['node_type'])
    )->condition('entity_id', array_keys($nodes))
    ->execute();
    foreach ($nodes as $nid => $node) {
      $insert->values(array(
        'entity_type' => 'node',
        'bundle' => $sandbox['node_type'],
        'entity_id' => $nid,
        'revision_id' => $node->vid,
        'langcode' => $node->langcode,
        'delta' => 0,
        'comment_node_' . $sandbox['node_type'] . '_comment' => $node->comment,
      ));
      $revision->values(array(
        'entity_type' => 'node',
        'bundle' => $sandbox['node_type'],
        'entity_id' => $nid,
        'revision_id' => $node->vid,
        'langcode' => $node->langcode,
        'delta' => 0,
        'comment_node_' . $sandbox['node_type'] . '_comment' => $node->comment,
      ));
      $sandbox['progress']++;
      $sandbox['current_nid'] = $nid;
    }
    $insert->execute();
    $revision->execute();
  }
  else {
    // Move to the next node type.
    $sandbox['node_type'] = array_shift($sandbox['node_types']);
    // Reset the current nid pointer.
    $sandbox['current_nid'] = 0;
  }
  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress'] / $sandbox['max']);

  $t = get_t();
  return $t('Migrated existing node comment settings to field api.');
}

/**
 * Removes the existing fields.
 */
function comment_update_8008(&$sandbox) {
  // Remove the {node}.comment field.
  db_drop_field('node', 'comment');
  // Remove the {node_revision}.comment field.
  db_drop_field('node_revision', 'comment');
  $t = get_t();
  return $t('Removed old fields.');
}


/**
 * @} End of "addtogroup updates-7.x-to-8.x".
 * The next series of updates should start at 9000.
 */
