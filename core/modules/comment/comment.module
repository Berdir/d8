<?php

/**
 * @file
 * Enables users to comment on published content.
 *
 * When enabled, the Comment module creates a field that facilitates a
 * discussion board for each Drupal entity to which a comment field is attached.
 * Users can post comments to discuss a forum topic, story, collaborative
 * book page, user etc.
 */

use Drupal\entity\Plugin\Core\Entity\EntityDisplay;
use Drupal\file\Plugin\Core\Entity\File;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityNG;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\HttpKernel\HttpKernelInterface;

// Load all Field module hooks for Comment.
require_once DRUPAL_ROOT . '/core/modules/comment/comment.field.inc';

/**
 * Comment is awaiting approval.
 */
const COMMENT_NOT_PUBLISHED = 0;

/**
 * Comment is published.
 */
const COMMENT_PUBLISHED = 1;

/**
 * Comments are displayed in a flat list - expanded.
 */
const COMMENT_MODE_FLAT = 0;

/**
 * Comments are displayed as a threaded list - expanded.
 */
const COMMENT_MODE_THREADED = 1;

/**
 * Anonymous posters cannot enter their contact information.
 */
const COMMENT_ANONYMOUS_MAYNOT_CONTACT = 0;

/**
 * Anonymous posters may leave their contact information.
 */
const COMMENT_ANONYMOUS_MAY_CONTACT = 1;

/**
 * Anonymous posters are required to leave their contact information.
 */
const COMMENT_ANONYMOUS_MUST_CONTACT = 2;

/**
 * Comment form should be displayed on a separate page.
 */
const COMMENT_FORM_SEPARATE_PAGE = 0;

/**
 * Comment form should be shown below post or list of comments.
 */
const COMMENT_FORM_BELOW = 1;

/**
 * Comments for this entity are hidden.
 */
const COMMENT_HIDDEN = 0;

/**
 * Comments for this entity are closed.
 */
const COMMENT_CLOSED = 1;

/**
 * Comments for this entity are open.
 */
const COMMENT_OPEN = 2;

/**
 * Denotes that access is denied for an entity to which a comment field is
 * attached and no {%entity_type}_access function exists.
 *
 * Modules should return this value from hook_comment_access() to deny
 * access to commenting on an entity
 */
const COMMENT_ACCESS_DENY = 'deny';

/**
 * The time cutoff for comments marked as read for entity types other node.
 *
 * Comments changed before this time are always marked as read.
 * Comments changed after this time may be marked new, updated, or read,
 * depending on their state for the current user. Defaults to 30 days ago.
 *
 * @todo remove when http://drupal.org/node/1029708 lands.
 */
define('COMMENT_NEW_LIMIT', REQUEST_TIME - 30 * 24 * 60 * 60);

use Drupal\comment\Plugin\Core\Entity\Comment;

/**
 * Implements hook_help().
 */
function comment_help($path, $arg) {
  switch ($path) {
    case 'admin/help#comment':
      $output = '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Comment module allows users to comment on site content, set commenting defaults and permissions, and moderate comments. For more information, see the online handbook entry for <a href="@comment">Comment module</a>.', array('@comment' => 'http://drupal.org/documentation/modules/comment')) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Default and custom settings') . '</dt>';
      $output .= '<dd>' . t("Comment functionality can be attached to any Drupal entity, eg a content <a href='@content-type'> type</a> and the behavior can be customised to suit. Each entity can have its own default comment settings configured as: <em>Open</em> to allow new comments, <em>Hidden</em> to hide existing comments and prevent new comments, or <em>Closed</em> to view existing comments, but prevent new comments. These defaults will apply to all new content created (changes to the settings on existing content must be done manually). Other comment settings can also be customized per content type and entity, and can be overridden for any given item of content. When a comment has no replies, it remains editable by its author, as long as the author has a user account and is logged in.", array('@content-type' => url('admin/structure/types'))) . '</dd>';
      $output .= '<dt>' . t('Comment approval') . '</dt>';
      $output .= '<dd>' . t("Comments from users who have the <em>Skip comment approval</em> permission are published immediately. All other comments are placed in the <a href='@comment-approval'>Unapproved comments</a> queue, until a user who has permission to <em>Administer comments</em> publishes or deletes them. Published comments can be bulk managed on the <a href='@admin-comment'>Published comments</a> administration page.", array('@comment-approval' => url('admin/content/comment/approval'), '@admin-comment' => url('admin/content/comment'))) . '</dd>';
      $output .= '</dl>';
      return $output;
  }
}

/**
 * Implements hook_entity_view().
 *
 * @todo Make node links as comment_links formatter http://drupal.org/node/1901110
 */
function comment_entity_view(EntityInterface $entity, EntityDisplay $display, $view_mode, $langcode) {
  if ($entity->entityType() != 'node') {
    // Only content needs comment links.
    return;
  }
  $fields = field_info_instances($entity->entityType(), $entity->bundle());
  foreach ($fields as $field_name => $instance) {
    $links = array();
    $field = field_info_field($field_name);
    if ($field['type'] != 'comment') {
      continue;
    }
    $commenting_status = _comment_get_default_status(field_get_items($entity, $field_name));
    if ($commenting_status) {
      // Entity have commenting open or close.
      $uri = $entity->uri();
      if ($view_mode == 'rss') {
        // Add a comments RSS element which is a URL to the comments of this node.
        if (!empty($uri['options'])) {
          $uri['options']['fragment'] = 'comments';
          $uri['options']['absolute'] = TRUE;
        }
        $entity->rss_elements[] = array(
          'key' => 'comments',
          'value' => url($uri['path'], $uri['options'])
        );
      }
      elseif ($view_mode == 'teaser') {
        // Teaser view: display the number of comments that have been posted,
        // or a link to add new comments if the user has permission, the node
        // is open to new comments, and there currently are none.
        if (user_access('access comments')) {
          if (!empty($entity->comment_statistics[$field_name]->comment_count)) {
            $links['comment-comments'] = array(
              'title' => format_plural($entity->comment_statistics[$field_name]->comment_count, '1 comment', '@count comments'),
              'href' => $uri['path'],
              'attributes' => array('title' => t('Jump to the first comment of this posting.')),
              'fragment' => 'comments',
              'html' => TRUE,
            );
            // Show a link to the first new comment.
            if ($new = comment_num_new($entity->id(), $entity->entityType(), $field_name)) {
              $links['comment-new-comments'] = array(
                'title' => format_plural($new, '1 new comment', '@count new comments'),
                'href' => $uri['path'],
                'query' => comment_new_page_count($entity->comment_statistics[$field_name]->comment_count, $new, $entity, $field_name),
                'attributes' => array('title' => t('Jump to the first new comment of this posting.')),
                'fragment' => 'new',
                'html' => TRUE,
              );
            }
          }
        }
        // Provide a link to new comment form.
        if ($commenting_status == COMMENT_OPEN) {
          $comment_form_location = $instance['settings']['form_location'];
          if (user_access('post comments')) {
            $links['comment-add'] = array(
              'title' => t('Add new comment'),
              'href' => $uri['path'],
              'attributes' => array('title' => t('Add a new comment to this page.')),
              'fragment' => 'comment-form',
            );
            if ($comment_form_location == COMMENT_FORM_SEPARATE_PAGE) {
              $links['comment-add']['href'] = 'comment/reply/'. $entity->entityType() . '/' . $entity->id() .'/' . $field_name;
            }
          }
          else {
            $links['comment-forbidden'] = array(
              'title' => theme('comment_post_forbidden', array('entity' => $entity, 'field_name' => $field_name)),
              'html' => TRUE,
            );
          }
        }
      }
      elseif ($view_mode != 'search_index' && $view_mode != 'search_result') {
        // Entity in other view modes: add a "post comment" link if the user is
        // allowed to post comments and if this entity is allowing new comments.
        // But we don't want this link if we're building the entity for search
        // indexing or constructing a search result excerpt.
        if ($commenting_status == COMMENT_OPEN) {
          $comment_form_location = $instance['settings']['form_location'];
          if (user_access('post comments')) {
            // Show the "post comment" link if the form is on another page, or
            // if there are existing comments that the link will skip past.
            if ($comment_form_location == COMMENT_FORM_SEPARATE_PAGE || (!empty($entity->comment_statistics[$field_name]->comment_count) && user_access('access comments'))) {
              $links['comment-add'] = array(
                'title' => t('Add new comment'),
                'attributes' => array('title' => t('Share your thoughts and opinions related to this item.')),
                'href' => $uri['path'],
                'fragment' => 'comment-form',
              );
              if ($comment_form_location == COMMENT_FORM_SEPARATE_PAGE) {
                $links['comment-add']['href'] = 'comment/reply/'. $entity->entityType() . '/' . $entity->id() .'/' . $field_name;
              }
            }
          }
          else {
            $links['comment-forbidden'] = array(
              'title' => theme('comment_post_forbidden', array('entity' => $entity, 'field_name' => $field_name)),
              'html' => TRUE,
            );
          }
        }
      }
    }

    $entity->content['links']['comment__' . $field_name] = array(
      '#theme' => 'links__entity__comment__' . $field_name,
      '#links' => $links,
      '#attributes' => array('class' => array('links', 'inline')),
    );
  }
}

/**
 * Implements hook_entity_view_mode_info().
 */
function comment_entity_view_mode_info() {
  $view_modes['comment']['full'] = array(
    'label' => t('Full comment'),
  );
  return $view_modes;
}

/**
 * Implements hook_entity_bundle_info().
 */
function comment_entity_bundle_info() {
  $bundles = array();
  foreach (comment_get_comment_fields() as $field_name => $field_info) {
    $bundles['comment'][$field_name] = array(
      'label' => $field_name,
      'admin' => array(
        'path' => 'admin/structure/comments/%comment_field_name',
        'bundle argument' => 3,
        'real path' => 'admin/structure/comments/' . $field_name,
      ),
    );
  }
  return $bundles;
}

/**
 * Menu callback for loading the actual name of a comment field.
 *
 * @param string $field_name
 *   The name of the field to load.
 *
 * @return string|false
 *   The field name as returned by field_info_field() or FALSE if $field_name
 *   is not a comment field.
 */
function comment_field_name_load($field_name) {
  if (($field = field_info_field($field_name)) && $field['type'] == 'comment') {
    return $field['field_name'];
  }

  return FALSE;
}

/**
 * Entity URI callback.
 */
function comment_uri(Comment $comment) {
  return array(
    'path' => 'comment/' . $comment->id(),
    'options' => array('fragment' => 'comment-' . $comment->id()),
  );
}

/**
 * Implements hook_field_extra_fields().
 */
function comment_field_extra_fields() {
  $return = array();
  foreach (comment_get_comment_fields() as $field_name => $field_info) {
    $return['comment'][$field_name] = array(
      'form' => array(
        'author' => array(
          'label' => t('Author'),
          'description' => t('Author textfield'),
          'weight' => -2,
        ),
        'subject' => array(
          'label' => t('Subject'),
          'description' => t('Subject textfield'),
          'weight' => -1,
        ),
      ),
    );
  }

  return $return;
}

/**
 * Implements hook_theme().
 */
function comment_theme() {
  return array(
    'comment_block' => array(
      'variables' => array('number' => NULL),
    ),
    'comment_preview' => array(
      'variables' => array('comment' => NULL),
    ),
    'comment' => array(
      'template' => 'comment',
      'render element' => 'elements',
    ),
    'comment_post_forbidden' => array(
      'variables' => array('entity' => NULL, 'field_name' => 'comment'),
    ),
    'comment_wrapper' => array(
      'template' => 'comment-wrapper',
      'render element' => 'content',
    ),
  );
}

/**
 * Implements hook_menu().
 */
function comment_menu() {
  $items['admin/structure/comments'] = array(
    'title' => 'Comment forms',
    'description' => 'Manage fields and displays settings for comment forms.',
    'page callback' => 'comment_overview_bundles',
    'access arguments' => array('administer comments'),
    'file' => 'comment.admin.inc',
  );
  $items['admin/content/comment'] = array(
    'title' => 'Comments',
    'description' => 'List and edit site comments and the comment approval queue.',
    'page callback' => 'comment_admin',
    'access arguments' => array('administer comments'),
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'comment.admin.inc',
  );
  // Tabs begin here.
  $items['admin/content/comment/new'] = array(
    'title' => 'Published comments',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/content/comment/approval'] = array(
    'title' => 'Unapproved comments',
    'title callback' => 'comment_count_unpublished',
    'page arguments' => array('approval'),
    'access arguments' => array('administer comments'),
    'type' => MENU_LOCAL_TASK,
  );
  $items['comment/%'] = array(
    'title' => 'Comment permalink',
    'page callback' => 'comment_permalink',
    'page arguments' => array(1),
    'access arguments' => array('access comments'),
  );
  $items['comment/%/view'] = array(
    'title' => 'View comment',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  // Every other comment path uses %, but this one loads the comment directly,
  // so we don't end up loading it twice (in the page and access callback).
  $items['comment/%comment/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'comment_edit_page',
    'page arguments' => array(1),
    'access callback' => 'comment_access',
    'access arguments' => array('edit', 1),
    'type' => MENU_LOCAL_TASK,
  );
  $items['comment/%/approve'] = array(
    'title' => 'Approve',
    'page callback' => 'comment_approve',
    'page arguments' => array(1),
    'access arguments' => array('administer comments'),
    'file' => 'comment.pages.inc',
    'weight' => 10,
  );
  $items['comment/%/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'comment_confirm_delete_page',
    'page arguments' => array(1),
    'access arguments' => array('administer comments'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'comment.admin.inc',
    'weight' => 20,
  );
  $items['comment/reply/%/%comment_entity_reply/%'] = array(
    'title' => 'Add new comment',
    'page callback' => 'comment_reply',
    'page arguments' => array(3, 4),
    'load arguments' => array('%map'),
    'access callback' => 'comment_reply_access',
    'access arguments' => array(3),
    'file' => 'comment.pages.inc',
  );
  // Legacy redirect handler for links of form comment/reply/%nid
  if (module_exists('node')) {
    $items['comment/reply/%node'] = array(
      'title' => 'Add new comment',
      'page callback' => 'comment_node_redirect',
      'page arguments' => array(2),
      'access callback' => 'node_access',
      'access arguments' => array('view', 2),
      'file' => 'comment.pages.inc',
    );
  }

  return $items;
}

/**
 * Dynamic menu loader callback for comment/reply/%/%comment_entity/%.
 *
 * Loads the entity given and entity id and entity type
 *
 * @param integer $entity_id
 *   The entity ID.
 * @param array $args
 *   The menu args passed from the %map load argument.
 *
 * @return \Drupal\Core\Entity\EntityInterface|false
 *   Returns an entity object or FALSE if not found.
 */
function comment_entity_reply_load($entity_id, $args) {
  list(, ,$entity_type, $entity_id, $field_name) = $args;
  return entity_load($entity_type, $entity_id);
}

/**
 * Access callback for testing user has access to view the subject of comments.
 *
 * Checks the user has view access to the entity which the comment reply is
 * against.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity which the comment field is attached to.
 *
 * @return bool
 *   TRUE or FALSE if the user has access
 */
function comment_reply_access(EntityInterface $entity) {
  $function = $entity->entityType() . '_access';
  // @todo replace this with entity access controls once generic access
  // controller lands.
  // @see http://drupal.org/node/1696660
  if (function_exists($function)) {
    switch ($function) {
      case 'user_access':
        return $entity->access('view');

      case 'taxonomy_term_access':
        return user_access('access content');

      default:
        return $function('view', $entity);
    }
  }

  // We can't know how to control access to this entity, invoke
  // hook_comment_access and if no other modules object, grant access.
  $access = module_invoke_all('comment_access', $entity);
  return !in_array(COMMENT_ACCESS_DENY, $access, TRUE);
}

/**
 * Returns a menu title which includes the number of unapproved comments.
 *
 * @return string
 */
function comment_count_unpublished() {
  $count = db_query('SELECT COUNT(cid) FROM {comment} WHERE status = :status', array(
    ':status' => COMMENT_NOT_PUBLISHED,
  ))->fetchField();
  return t('Unapproved comments (@count)', array('@count' => $count));
}

 /**
 * Creates a comment_body field instance.
 *
 * @param string $entity_type
 *   Entity type to which the comment field is attached.
 * @param string $bundle
 *   Bundle of entity type to which comment field is attached
 * @param string $field_name
 *   Name of the comment field attached to the entity type and bundle.
 */
function _comment_body_field_create($entity_type, $bundle, $field_name) {
  // Create the field if needed.
  if (!field_read_field('comment_body', array('include_inactive' => TRUE))) {
    $field = array(
      'field_name' => 'comment_body',
      'type' => 'text_long',
      'entity_types' => array('comment'),
    );
    field_create_field($field);
  }
  // Create the instance if needed, field name defaults to 'comment'.
  if (!field_read_instance('comment', 'comment_body', $field_name, array('include_inactive' => TRUE))) {
    field_attach_create_bundle('comment', $bundle);
    // Attaches the body field by default.
    $instance = array(
      'field_name' => 'comment_body',
      'label' => 'Comment',
      'entity_type' => 'comment',
      'bundle' => $field_name,
      'settings' => array('text_processing' => 1),
      'required' => TRUE,
    );
    field_create_instance($instance);
    entity_get_display('comment', $field_name, 'default')
      ->setComponent('comment_body', array(
        'label' => 'hidden',
        'type' => 'text_default',
        'weight' => 0,
      ))
      ->save();
  }
}

/**
 * Implements hook_permission().
 */
function comment_permission() {
  return array(
    'administer comments' => array(
      'title' => t('Administer comments and comment settings'),
    ),
    'access comments' => array(
      'title' => t('View comments'),
    ),
    'post comments' => array(
      'title' => t('Post comments'),
    ),
    'skip comment approval' => array(
      'title' => t('Skip comment approval'),
    ),
    'edit own comments' => array(
      'title' => t('Edit own comments'),
    ),
  );
}

/**
 * Redirects comment links to the correct page depending on comment settings.
 *
 * Since comments are paged there is no way to guarantee which page a comment
 * appears on. Comment paging and threading settings may be changed at any time.
 * With threaded comments, an individual comment may move between pages as
 * comments can be added either before or after it in the overall discussion.
 * Therefore we use a central routing function for comment links, which
 * calculates the page number based on current comment settings and returns
 * the full comment view with the pager set dynamically.
 *
 * @param $cid
 *   A comment identifier.
 *
 * @return
 *   The comment listing set to the page on which the comment appears.
 */
function comment_permalink($cid) {
  if (($comment = comment_load($cid)) && ($entity = entity_load($comment->entity_type->value, $comment->entity_id->target_id))) {

    $instance = field_info_instance($entity->entityType(), $comment->field_name->value, $entity->bundle());
    // Find the current display page for this comment.
    $page = comment_get_display_page($comment->id(), $instance);

    // @todo: Cleaner sub request handling.
    $request = drupal_container()->get('request');
    $uri = $entity->uri();
    $subrequest = Request::create($uri['path'], 'GET', $request->query->all(), $request->cookies->all(), array(), $request->server->all());
    $subrequest->query->set('page', $page);
    // @todo: Convert the pager to use the request object.
    $_GET['page'] = $page;
    return drupal_container()->get('http_kernel')->handle($subrequest, HttpKernelInterface::SUB_REQUEST);
  }
  throw new NotFoundHttpException();
}

/**
 * Finds the most recent comments that are available to the current user.
 *
 * @param integer $number
 *   (optional) The maximum number of comments to find. Defaults to 10.
 *
 * @return
 *   An array of comment objects or an empty array if there are no recent
 *   comments visible to the current user.
 *
 * @todo entity access for other entity types?
 */
function comment_get_recent($number = 10) {
  $query = db_select('comment', 'c');
  $query->addMetaData('base_table', 'comment');
  $query->fields('c')
    ->condition('c.status', COMMENT_PUBLISHED);
  if (module_exists('node')) {
    // Special case to filter by published content.
    $query->leftJoin('node', 'n', "n.nid = c.entity_id AND c.entity_type = 'node'");
    $query->addTag('node_access');
    $query->condition(db_or()
      ->condition('n.status', NODE_PUBLISHED)
      ->isNull('n.status')
    );
  }
  $comments = $query->orderBy('c.created', 'DESC')
    // Additionally order by cid to ensure that comments with the same timestamp
    // are returned in the exact order posted.
    ->orderBy('c.cid', 'DESC')
    ->range(0, $number)
    ->execute()
    ->fetchAll();

  return $comments ? $comments : array();
}

/**
 * Calculates the page number for the first new comment.
 *
 * @param int $num_comments
 *   Number of comments.
 * @param int $new_replies
 *   Number of new replies.
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The first new comment entity.
 * @param string $field_name
 *   The field name
 *
 * @return
 *   "page=X" if the page number is greater than zero; empty string otherwise.
 */
function comment_new_page_count($num_comments, $new_replies, EntityInterface $entity, $field_name = 'comment') {
  $instance = field_info_instance($entity->entityType(), $field_name, $entity->bundle());
  $mode = $instance['settings']['default_mode'];
  $comments_per_page = $instance['settings']['per_page'];
  $pagenum = NULL;
  $flat = $mode == COMMENT_MODE_FLAT ? TRUE : FALSE;
  if ($num_comments <= $comments_per_page) {
    // Only one page of comments.
    $pageno = 0;
  }
  elseif ($flat) {
    // Flat comments.
    $count = $num_comments - $new_replies;
    $pageno = $count / $comments_per_page;
  }
  else {
    // Threaded comments: we build a query with a subquery to find the first
    // thread with a new comment.

    // 1. Find all the threads with a new comment.
    $unread_threads_query = db_select('comment')
      ->fields('comment', array('thread'))
      ->condition('entity_id', $entity->id())
      ->condition('entity_type', $entity->entityType())
      ->condition('field_name', $field_name)
      ->condition('status', COMMENT_PUBLISHED)
      ->orderBy('created', 'DESC')
      ->orderBy('cid', 'DESC')
      ->range(0, $new_replies);

    // 2. Find the first thread.
    $first_thread = db_select($unread_threads_query, 'thread')
      ->fields('thread', array('thread'))
      ->orderBy('SUBSTRING(thread, 1, (LENGTH(thread) - 1))')
      ->range(0, 1)
      ->execute()
      ->fetchField();

    // Remove the final '/'.
    $first_thread = substr($first_thread, 0, -1);

    // Find the number of the first comment of the first unread thread.
    $count = db_query('SELECT COUNT(*) FROM {comment} WHERE entity_id = :entity_id
                      AND entity_type = :entity_type
                      AND field_name = :field_name
                      AND status = :status AND SUBSTRING(thread, 1, (LENGTH(thread) - 1)) < :thread', array(
      ':status' => COMMENT_PUBLISHED,
      ':entity_id' => $entity->id(),
      ':field_name' => $field_name,
      ':entity_type' => $entity->entityType(),
      ':thread' => $first_thread,
    ))->fetchField();

    $pageno = $count / $comments_per_page;
  }

  if ($pageno >= 1) {
    $pagenum = array('page' => intval($pageno));
  }

  return $pagenum;
}

/**
 * Returns HTML for a list of recent comments.
 *
 * @ingroup themeable
 */
function theme_comment_block($variables) {
  $items = array();
  $number = $variables['number'];
  foreach (comment_get_recent($number) as $comment) {
    $items[] = l($comment->subject, 'comment/' . $comment->cid, array('fragment' => 'comment-' . $comment->cid)) . '&nbsp;<span>' . t('@time ago', array('@time' => format_interval(REQUEST_TIME - $comment->changed))) . '</span>';
  }

  if ($items) {
    return theme('item_list', array('items' => $items));
  }
  else {
    return t('No comments available.');
  }
}

/**
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity to which the comments are in reply to.
 * @param string $field_name
 *   The field name where the comments were entered.
 * @param int $pid
 *   (optional) Some comments are replies to other comments. In those cases,
 *   $pid is the parent comment's comment ID. Defaults to NULL.
 *
 * @return array
 *   The renderable array for the comment addition form.
 */
function comment_add(EntityInterface $entity, $field_name = 'comment', $pid = NULL) {
  $values = array('entity_id' => $entity->id(), 'pid' => $pid, 'entity_type' => $entity->entityType(), 'field_name' => $field_name);
  $comment = entity_create('comment', $values);

  return entity_get_form($comment);
}

/**
 * Retrieves comments for a thread.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity whose comment(s) needs rendering.
 * @param string $field_name
 *   The field_name whose comment(s) needs rendering.
 * @param int $mode
 *   The comment display mode; COMMENT_MODE_FLAT or COMMENT_MODE_THREADED.
 * @param int $comments_per_page
 *   The amount of comments to display per page.
 *
 * @return
 *   An array of the IDs of the comment to be displayed.
 *
 * To display threaded comments in the correct order we keep a 'thread' field
 * and order by that value. This field keeps this data in
 * a way which is easy to update and convenient to use.
 *
 * A "thread" value starts at "1". If we add a child (A) to this comment,
 * we assign it a "thread" = "1.1". A child of (A) will have "1.1.1". Next
 * brother of (A) will get "1.2". Next brother of the parent of (A) will get
 * "2" and so on.
 *
 * First of all note that the thread field stores the depth of the comment:
 * depth 0 will be "X", depth 1 "X.X", depth 2 "X.X.X", etc.
 *
 * Now to get the ordering right, consider this example:
 *
 * 1
 * 1.1
 * 1.1.1
 * 1.2
 * 2
 *
 * If we "ORDER BY thread ASC" we get the above result, and this is the
 * natural order sorted by time. However, if we "ORDER BY thread DESC"
 * we get:
 *
 * 2
 * 1.2
 * 1.1.1
 * 1.1
 * 1
 *
 * Clearly, this is not a natural way to see a thread, and users will get
 * confused. The natural order to show a thread by time desc would be:
 *
 * 2
 * 1
 * 1.2
 * 1.1
 * 1.1.1
 *
 * which is what we already did before the standard pager patch. To achieve
 * this we simply add a "/" at the end of each "thread" value. This way, the
 * thread fields will look like this:
 *
 * 1/
 * 1.1/
 * 1.1.1/
 * 1.2/
 * 2/
 *
 * we add "/" since this char is, in ASCII, higher than every number, so if
 * now we "ORDER BY thread DESC" we get the correct order. However this would
 * spoil the reverse ordering, "ORDER BY thread ASC" -- here, we do not need
 * to consider the trailing "/" so we use a substring only.
 */
function comment_get_thread(EntityInterface $entity, $field_name, $mode, $comments_per_page) {
  $query = db_select('comment', 'c')
    ->extend('Drupal\Core\Database\Query\PagerSelectExtender');
  $query->addField('c', 'cid');
  $query
    ->condition('c.entity_id', $entity->id())
    ->condition('c.entity_type', $entity->entityType())
    ->condition('c.field_name', $field_name)
    ->addTag('entity_access')
    ->addTag('comment_filter')
    ->addMetaData('base_table', 'comment')
    ->addMetaData('entity', $entity)
    ->addMetaData('field_name', $field_name)
    ->limit($comments_per_page);

  $count_query = db_select('comment', 'c');
  $count_query->addExpression('COUNT(*)');
  $count_query
    ->condition('c.entity_id', $entity->id())
    ->condition('c.entity_type', $entity->entityType())
    ->condition('c.field_name', $field_name)
    ->addTag('entity_access')
    ->addTag('comment_filter')
    ->addMetaData('base_table', 'comment')
    ->addMetaData('entity', $entity)
    ->addMetaData('field_name', $field_name);

  if (!user_access('administer comments')) {
    $query->condition('c.status', COMMENT_PUBLISHED);
    $count_query->condition('c.status', COMMENT_PUBLISHED);
  }
  if ($mode === COMMENT_MODE_FLAT) {
    $query->orderBy('c.cid', 'ASC');
  }
  else {
    // See comment above. Analysis reveals that this doesn't cost too
    // much. It scales much much better than having the whole comment
    // structure.
    $query->addExpression('SUBSTRING(c.thread, 1, (LENGTH(c.thread) - 1))', 'torder');
    $query->orderBy('torder', 'ASC');
  }

  $query->setCountQuery($count_query);
  $cids = $query->execute()->fetchCol();

  return $cids;
}

/**
 * Calculates the indentation level of each comment in a comment thread.
 *
 * This function loops over an array representing a comment thread. For each
 * comment, the function calculates the indentation level and saves it in the
 * 'divs' property of the comment object.
 *
 * @param array $comments
 *   An array of comment objects, keyed by comment ID.
 */
function comment_prepare_thread(&$comments) {
  // A flag stating if we are still searching for first new comment on the thread.
  $first_new = TRUE;

  // A counter that helps track how indented we are.
  $divs = 0;

  foreach ($comments as $key => $comment) {
    if ($first_new && $comment->new->value != MARK_READ) {
      // Assign the anchor only for the first new comment. This avoids duplicate
      // id attributes on a page.
      $first_new = FALSE;
      $comment->first_new = TRUE;
    }

    // The $divs element instructs #prefix whether to add an indent div or
    // close existing divs (a negative value).
    $comment->depth = count(explode('.', $comment->thread->value)) - 1;
    if ($comment->depth > $divs) {
      $comment->divs = 1;
      $divs++;
    }
    else {
      $comment->divs = $comment->depth - $divs;
      while ($comment->depth < $divs) {
        $divs--;
      }
    }
    $comments[$key] = $comment;
  }

  // The final comment must close up some hanging divs
  $comments[$key]->divs_final = $divs;
}

/**
 * Generates an array for rendering a comment.
 *
 * @param \Drupal\comment\Plugin\Core\Entity\comment $comment
 *   The comment object.
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity the comment is attached to.
 * @param $view_mode
 *   (optional) View mode, e.g. 'full', 'teaser'... Defaults to 'full'.
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 *
 * @return
 *   An array as expected by drupal_render().
 */
function comment_view(Comment $comment, $view_mode = 'full', $langcode = NULL) {
  return entity_view($comment, $view_mode, $langcode);
}

/**
 * Adds reply, edit, delete, etc. links, depending on user permissions.
 *
 * @param \Drupal\comment\Plugin\Core\Entity\comment $comment
 *   The comment object.
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity the comment is attached to.
 * @param string $field_name
 *   The field the comment is attached to.
 *
 * @return
 *   A structured array of links.
 */
function comment_links(Comment $comment, EntityInterface $entity, $field_name) {
  $links = array();
  $status = _comment_get_default_status(field_get_items($entity, $field_name));
  if ($status == COMMENT_OPEN) {
    if (user_access('administer comments') && user_access('post comments')) {
      $links['comment-delete'] = array(
        'title' => t('delete'),
        'href' => "comment/{$comment->id()}/delete",
        'html' => TRUE,
      );
      $links['comment-edit'] = array(
        'title' => t('edit'),
        'href' => "comment/{$comment->id()}/edit",
        'html' => TRUE,
      );
      $links['comment-reply'] = array(
        'title' => t('reply'),
        'href' => "comment/reply/{$comment->entity_type->value}/{$comment->entity_id->target_id}/{$comment->field_name->value}/{$comment->id()}",
        'html' => TRUE,
      );
      if ($comment->status->value == COMMENT_NOT_PUBLISHED) {
        $links['comment-approve'] = array(
          'title' => t('approve'),
          'href' => "comment/{$comment->id()}/approve",
          'html' => TRUE,
          'query' => array('token' => drupal_get_token("comment/{$comment->id()}/approve")),
        );
      }
    }
    elseif (user_access('post comments')) {
      if (comment_access('edit', $comment)) {
        $links['comment-edit'] = array(
          'title' => t('edit'),
          'href' => "comment/{$comment->id()}/edit",
          'html' => TRUE,
        );
      }
      $links['comment-reply'] = array(
        'title' => t('reply'),
        'href' => "comment/reply/{$comment->entity_type->value}/{$comment->entity_id->target_id}/{$comment->field_name->value}/{$comment->id()}",
        'html' => TRUE,
      );
    }
    else {
      $links['comment-forbidden']['title'] = theme('comment_post_forbidden', array(
        'entity' => $entity,
        'field_name' => $field_name
      ));
      $links['comment-forbidden']['html'] = TRUE;
    }
  }

  // Add translations link for translation-enabled comment bundles.
  if (module_exists('translation_entity') && translation_entity_translate_access($comment)) {
    $links['comment-translations'] = array(
      'title' => t('translations'),
      'href' => 'comment/' . $comment->id() . '/translations',
      'html' => TRUE,
    );
  }

  return $links;
}

/**
 * Constructs render array from an array of loaded comments.
 *
 * @param $comments
 *   An array of comments as returned by comment_load_multiple().
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $langcode
 *   (optional) A string indicating the language field values are to be shown
 *   in. If no language is provided the current content language is used.
 *   Defaults to NULL.
 *
 * @return
 *   An array in the format expected by drupal_render().
 *
 * @see drupal_render()
 */
function comment_view_multiple($comments, $view_mode = 'full', $langcode = NULL) {
  return entity_view_multiple($comments, $view_mode, $langcode);
}

/**
 * Implements hook_form_FORM_ID_alter() for field_ui_field_edit_form().
 */
function comment_form_field_ui_field_edit_form_alter(&$form, $form_state) {
  if ($form['#field']['type'] == 'comment') {
    // Collect translation settings.
    if (module_exists('translation_entity')) {
      array_unshift($form['#submit'], 'comment_translation_configuration_element_submit');
    }

    // Hide required checkbox.
    $form['instance']['required']['#access'] = FALSE;
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for field_ui_field_settings_form().
 */
function comment_form_field_ui_field_settings_form_alter(&$form, $form_state) {
  if ($form['#field']['type'] == 'comment') {
    // We only support posting one comment at the time so it doesn't make sense
    // to let the site builder choose anything else.
    $form['field']['container']['cardinality']['#options'] = drupal_map_assoc(array(1));
    $form['field']['container']['#access'] = FALSE;
  }
}

/**
 * Form submission handler for field_ui_field_edit_form().
 *
 * This handles the comment translation settings added by
 * _comment_field_instance_settings_form_process().
 *
 * @see _comment_field_instance_settings_form_process()
 */
function comment_translation_configuration_element_submit($form, &$form_state) {
  // The comment translation settings form element is embedded into the instance
  // settings form. Hence we need to provide to the regular submit handler a
  // manipulated form state to make it process comment settings instead of the
  // host entity.
  $key = 'language_configuration';
  $comment_form_state = array(
    'translation_entity' => array('key' => $key),
    'language' => array($key => array('entity_type' => 'comment', 'bundle' => $form['#field']['field_name'])),
    'values' => array($key => array('translation_entity' => $form_state['values']['translation_entity'])),
  );
  translation_entity_language_configuration_element_submit($form, $comment_form_state);
}

/**
 * Implements hook_entity_load().
 */
function comment_entity_load($entities, $entity_type) {
  // Load comment information from the database and add it to the entity's
  // comment_statistics property, which is an array keyed by field_name.
  $result = db_select('comment_entity_statistics', 'ces')
    ->fields('ces')
    ->condition('ces.entity_id', array_keys($entities))
    ->condition('ces.entity_type', $entity_type)
    ->execute();
  foreach ($result as $record) {
    if (empty($entities[$record->entity_id]->comment_statistics)) {
      $entities[$record->entity_id]->comment_statistics = array();
    }

    if (empty($entities[$record->entity_id]->comment_statistics[$record->field_name])) {
      $entities[$record->entity_id]->comment_statistics[$record->field_name] = new \StdClass();
    }
    $comment_statistics = &$entities[$record->entity_id]->comment_statistics[$record->field_name];
    $comment_statistics->cid = $record->cid;
    $comment_statistics->last_comment_timestamp = $record->last_comment_timestamp;
    $comment_statistics->last_comment_name = $record->last_comment_name;
    $comment_statistics->last_comment_uid = $record->last_comment_uid;
    $comment_statistics->comment_count = $record->comment_count;
  }
}

/**
 * Implements hook_entity_insert().
 */
function comment_entity_insert($entity) {
  global $user;
  // Allow bulk updates and inserts to temporarily disable the
  // maintenance of the {comment_entity_statistics} table.
  $fields = comment_get_comment_fields($entity->entityType());
  if (state()->get('comment.maintain_entity_statistics', TRUE)) {
    $query = db_insert('comment_entity_statistics')
     ->fields(array(
      'entity_id',
      'entity_type',
      'field_name',
      'cid',
      'last_comment_timestamp',
      'last_comment_name',
      'last_comment_uid',
      'comment_count'
    ));
    foreach ($fields as $field_name => $detail) {
      // There is at least one comment field, the query needs to be executed.
      $query->values(array(
        'entity_id' => $entity->id(),
        'entity_type' => $entity->entityType(),
        'field_name' => $field_name,
        'cid' => 0,
        // Default to REQUEST_TIME when entity does not have a changed property.
        'last_comment_timestamp' => isset($entity->changed) ? $entity->changed : REQUEST_TIME,
        'last_comment_name' => NULL,
        // Default to current user when entity does not have a uid property.
        'last_comment_uid' => isset($entity->uid) ? $entity->uid : $user->uid,
        'comment_count' => 0,
      ));
    }
    $query->execute();
  }
}

/**
 * Implements hook_entity_predelete().
 */
function comment_entity_predelete($entity) {
  $cids = db_select('comment', 'c')
    ->fields('c', array('cid'))
    ->condition('entity_id', $entity->id())
    ->condition('entity_type', $entity->entityType())
    ->execute()
    ->fetchCol();
  comment_delete_multiple($cids);
  db_delete('comment_entity_statistics')
    ->condition('entity_id', $entity->id())
    ->condition('entity_type', $entity->entityType())
    ->execute();
}

/**
 * Implements hook_node_update_index().
 */
function comment_node_update_index(EntityInterface $node, $langcode) {
  $index_comments = &drupal_static(__FUNCTION__);

  if ($index_comments === NULL) {
    // Find and save roles that can 'access comments' or 'search content'.
    $perms = array('access comments' => array(), 'search content' => array());
    $result = db_query("SELECT rid, permission FROM {role_permission} WHERE permission IN ('access comments', 'search content')");
    foreach ($result as $record) {
      $perms[$record->permission][$record->rid] = $record->rid;
    }

    // Prevent indexing of comments if there are any roles that can search but
    // not view comments.
    $index_comments = TRUE;
    foreach ($perms['search content'] as $rid) {
      if (!isset($perms['access comments'][$rid]) && (($rid == DRUPAL_AUTHENTICATED_RID || $rid == DRUPAL_ANONYMOUS_RID) || !isset($perms['access comments'][DRUPAL_AUTHENTICATED_RID]))) {
        $index_comments = FALSE;
        break;
      }
    }
  }

  $return = '';

  if ($index_comments) {
    foreach (comment_get_comment_fields('node') as $field_name => $info) {
      $instance = field_info_instance('node', $field_name, $node->type);
      $mode = $instance['settings']['default_mode'];
      $comments_per_page = $instance['settings']['per_page'];
      if (($items = field_get_items($node, $field_name)) &&
        _comment_get_default_status($items) && $cids = comment_get_thread($node, $field_name, $mode, $comments_per_page)) {
        $comments = comment_load_multiple($cids);
        comment_prepare_thread($comments);
        $build = comment_view_multiple($comments);
        $return .= drupal_render($build);
      }
    }
  }
  return $return;
}

/**
 * Implements hook_update_index().
 */
function comment_update_index() {
  // Store the maximum possible comments per thread (used for ranking by reply count)
  state()->set('comment.node_comment_statistics_scale', 1.0 / max(1, db_query('SELECT MAX(comment_count) FROM {comment_entity_statistics}')->fetchField()));
}

/**
 * Implements hook_node_search_result().
 *
 * Formats a comment count string and returns it, for display with search
 * results.
 */
function comment_node_search_result(EntityInterface $node) {
  $comment_fields = comment_get_comment_fields('node');
  $comments = 0;
  $open = FALSE;
  foreach ($comment_fields as $field_name => $info) {
    // Do not make a string if comments are hidden.
    if (user_access('access comments') && ($items = field_get_items($node, $field_name)) &&
      isset($items[0]['status']) && $items[0]['status'] != COMMENT_HIDDEN) {
      if ($items[0]['status'] == COMMENT_OPEN) {
        // At least one comment field is open.
        $open = TRUE;
      }
      $comments += db_query("SELECT comment_count FROM {comment_entity_statistics} WHERE entity_id = :nid AND entity_type = 'node' AND field_name = :field_name", array(
        'nid' => $node->nid,
        'field_name' => $field_name)
      )->fetchField();
    }
  }
  // Do not make a string if there are no comment fields, or no comments exist
  // or all comment fields are hidden.
  if ($comments > 0 || $open) {
    return array('comment' => format_plural($comments, '1 comment', '@count comments'));
  }
}

/**
 * Implements hook_user_cancel().
 */
function comment_user_cancel($edit, $account, $method) {
  switch ($method) {
    case 'user_cancel_block_unpublish':
      $comments = entity_load_multiple_by_properties('comment', array('uid' => $account->uid));
      foreach ($comments as $comment) {
        $comment->status->value = 0;
        comment_save($comment);
      }
      break;

    case 'user_cancel_reassign':
      $comments = entity_load_multiple_by_properties('comment', array('uid' => $account->uid));
      foreach ($comments as $comment) {
        $comment->uid->target_id = 0;
        comment_save($comment);
      }
      break;
  }
}

/**
 * Implements hook_user_predelete().
 */
function comment_user_predelete($account) {
  $cids = db_query('SELECT c.cid FROM {comment} c WHERE uid = :uid', array(':uid' => $account->uid))->fetchCol();
  comment_delete_multiple($cids);
}

/**
 * Determines whether the current user has access to a particular comment.
 *
 * Authenticated users can edit their comments as long they have not been
 * replied to. This prevents people from changing or revising their statements
 * based on the replies to their posts.
 *
 * @param $op
 *   The operation that is to be performed on the comment. Only 'edit' is
 *   recognized now.
 * @param \Drupal\comment\Plugin\Core\Entity\comment $comment
 *   The comment object.
 *
 * @return
 *   TRUE if the current user has acces to the comment, FALSE otherwise.
 */
function comment_access($op, Comment $comment) {
  global $user;

  if ($op == 'edit') {
    return ($user->uid && $user->uid == $comment->uid->target_id && $comment->status->value == COMMENT_PUBLISHED && user_access('edit own comments')) || user_access('administer comments');
  }
}

/**
 * Accepts a submission of new or changed comment content.
 *
 * @param \Drupal\comment\Plugin\Core\Entity\comment $comment
 *   A comment object.
 */
function comment_save(Comment $comment) {
  $comment->save();
}

/**
 * Deletes a comment and all its replies.
 *
 * @param $cid
 *   The ID of the comment to delete.
 */
function comment_delete($cid) {
  comment_delete_multiple(array($cid));
}

/**
 * Deletes comments and all their replies.
 *
 * @param $cids
 *   The IDs of the comments to delete.
 *
 * @see hook_comment_predelete()
 * @see hook_comment_delete()
 */
function comment_delete_multiple($cids) {
  entity_delete_multiple('comment', $cids);
}

/**
 * Loads comment entities from the database.
 *
 * @param array $cids
 *   (optional) An array of entity IDs. If omitted, all entities are loaded.
 * @param bool $reset
 *   Whether to reset the internal static entity cache. Note that the static
 *   cache is disabled by default.
 *
 * @return array
 *   An array of comment objects, indexed by comment ID.
 *
 * @see entity_load()
 * @see Drupal\Core\Entity\Query\QueryInterface
 */
function comment_load_multiple(array $cids = NULL, $reset = FALSE) {
  return entity_load_multiple('comment', $cids, $reset);
}

/**
 * Loads the entire comment by comment ID.
 *
 * @param int $cid
 *   The ID of the comment to be loaded.
 * @param bool $reset
 *   Whether to reset the internal static entity cache. Note that the static
 *   cache is disabled by default.
 *
 * @return
 *   The comment object.
 */
function comment_load($cid, $reset = FALSE) {
  return entity_load('comment', $cid);
}

/**
 * Gets the number of new comments for the current user and the specified node.
 *
 * @param integer $entity_id
 *   Entity ID to count comments for.
 * @param string $entity_type
 *   The entity type to count comments for.
 * @param string $field_name
 *   (optional) The field_name to count comments for. Defaults to NULL.
 * @param $timestamp
 *   Time to count from (defaults to time of last user access
 *   to node).
 *
 * @return
 *   The number of new comments or FALSE if the user is not logged in.
 */
function comment_num_new($entity_id, $entity_type, $field_name = NULL, $timestamp = 0) {
  global $user;

  if ($user->uid && module_exists('history')) {
    // Retrieve the timestamp at which the current user last viewed this entity.
    if (!$timestamp) {
      if ($entity_type == 'node') {
        $timestamp = history_read($entity_id);
      }
      else {
        $function = $entity_type . '_last_viewed';
        if (function_exists($function)) {
          $timestamp = $function($entity_id);
        }
        else {
          // Default to 30 days ago.
          // @todo remove once http://drupal.org/node/1029708 lands.
          $timestamp = COMMENT_NEW_LIMIT;
        }
      }
    }
    $timestamp = ($timestamp > HISTORY_READ_LIMIT ? $timestamp : HISTORY_READ_LIMIT);

    // Use the timestamp to retrieve the number of new comments.
    $query = db_select('comment', 'c');
    $query->addExpression('COUNT(cid)');
    $query->condition('c.entity_type', $entity_type)
      ->condition('c.entity_id', $entity_id)
      ->condition('c.status', COMMENT_PUBLISHED)
      ->condition('c.created', $timestamp, '>');
    if ($field_name) {
      // Limit to a particular field.
      $query->condition('c.field_name', $field_name);
    }

    return $query->execute()
      ->fetchField();
  }
  else {
    return FALSE;
  }

}

/**
 * Gets the display ordinal for a comment, starting from 0.
 *
 * Count the number of comments which appear before the comment we want to
 * display, taking into account display settings and threading.
 *
 * @param integer $cid
 *   The comment ID.
 * @param array $instance
 *   Field instance as returned from field_info_instance.
 *
 * @return
 *   The display ordinal for the comment.
 *
 * @see comment_get_display_page()
 * @see field_info_instance().
 */
function comment_get_display_ordinal($cid, $instance) {
  // Count how many comments (c1) are before $cid (c2) in display order. This is
  // the 0-based display ordinal.
  $query = db_select('comment', 'c1');
  $query->innerJoin('comment', 'c2', 'c2.entity_id = c1.entity_id AND c2.entity_type = c1.entity_type AND c2.field_name = c1.field_name');
  $query->addExpression('COUNT(*)', 'count');
  $query->condition('c2.cid', $cid);
  if (!user_access('administer comments')) {
    $query->condition('c1.status', COMMENT_PUBLISHED);
  }
  $mode = $instance['settings']['default_mode'];

  if ($mode == COMMENT_MODE_FLAT) {
    // For flat comments, cid is used for ordering comments due to
    // unpredicatable behavior with timestamp, so we make the same assumption
    // here.
    $query->condition('c1.cid', $cid, '<');
  }
  else {
    // For threaded comments, the c.thread column is used for ordering. We can
    // use the sorting code for comparison, but must remove the trailing slash.
    // See CommentRenderController.
    $query->where('SUBSTRING(c1.thread, 1, (LENGTH(c1.thread) -1)) < SUBSTRING(c2.thread, 1, (LENGTH(c2.thread) -1))');
  }

  return $query->execute()->fetchField();
}

/**
 * Returns the page number for a comment.
 *
 * Finds the correct page number for a comment taking into account display
 * and paging settings.
 *
 * @param $cid
 *   The comment ID.
 * @param array $instance
 *   Field instance as returned from field_info_instance().
 *
 * @return
 *   The page number.
 */
function comment_get_display_page($cid, $instance) {
  $ordinal = comment_get_display_ordinal($cid, $instance);
  $comments_per_page = $instance['settings']['per_page'];
  return floor($ordinal / $comments_per_page);
}

/**
 * Page callback: Displays the comment editing form.
 *
 * @param \Drupal\comment\Plugin\Core\Entity\comment $comment
 *   The comment object representing the comment to be edited.
 *
 * @see comment_menu()
 */
function comment_edit_page(Comment $comment) {
  drupal_set_title(t('Edit comment %comment', array('%comment' => $comment->subject->value)), PASS_THROUGH);
  return entity_get_form($comment);
}

/**
 * Generates a comment preview.
 *
 * @param \Drupal\comment\Plugin\Core\Entity\comment $comment
 */
function comment_preview(Comment $comment) {
  global $user;
  $preview_build = array();
  $entity = entity_load($comment->entity_type->value, $comment->entity_id->target_id);

  if (!form_get_errors()) {
    // Attach the user and time information.
    if (!empty($comment->name->value)) {
      $account = user_load_by_name($comment->name->value);
    }
    elseif ($user->uid && empty($comment->is_anonymous)) {
      $account = $user;
    }

    if (!empty($account->uid)) {
      $comment->uid->target_id = $account->uid;
      $comment->name->value = check_plain($account->name);
    }
    elseif (empty($comment->name->value)) {
      $comment->name->value = config('user.settings')->get('anonymous');
    }

    $comment->created->value = !empty($comment->created->value) ? $comment->created->value : REQUEST_TIME;
    $comment->changed->value = REQUEST_TIME;
    $comment->in_preview = TRUE;
    $comment_build = comment_view($comment);
    $comment_build['#weight'] = -100;

    $preview_build['comment_preview'] = $comment_build;
  }

  if ($comment->pid->target_id) {
    $build = array();
    $parent = $comment->pid->entity;
    if ($parent && $parent->status->value == COMMENT_PUBLISHED) {
      $build = comment_view($parent);
    }
  }
  else {
    // We temporarily disable rendering of this field to prevent infinite
    // loop.
    $values = $entity->{$comment->field_name->value};
    $entity->{$comment->field_name->value} = array(
      LANGUAGE_NOT_SPECIFIED => array(array('status' => COMMENT_HIDDEN)),
    );
    $build = entity_view($entity, 'full');
    $entity->{$comment->field_name->value} = $values;
  }

  $preview_build['comment_output_below'] = $build;
  $preview_build['comment_output_below']['#weight'] = 100;

  return $preview_build;
}

/**
 * Implements hook_preprocess_HOOK() for block.tpl.php.
 */
function comment_preprocess_block(&$variables) {
  if ($variables['block']->module == 'comment') {
    $variables['attributes']['role'] = 'navigation';
  }
}

/**
 * Prepares a user account object for rendering comment authors.
 *
 * This helper handles anonymous authors in addition to registered comment
 * authors.
 *
 * @return \Drupal\user\Plugin\Core\Entity\User
 *   A user account, for use with theme_username() or the user_picture template.
 */
function comment_prepare_author(Comment $comment) {
  // The account has been pre-loaded by CommentRenderController::buildContent().
  $account = $comment->uid->entity;
  if (!$account) {
    $account = entity_create('user', array('uid' => 0, 'name' => $comment->name->value, 'homepage' => $comment->homepage->value));
  }
  return $account;
}

/**
 * Preprocesses variables for comment.tpl.php.
 *
 * @see comment.tpl.php
 */
function template_preprocess_comment(&$variables) {
  $comment = $variables['elements']['#comment'];
  $comment_entity = entity_load($comment->entity_type->value, $comment->entity_id->target_id);
  $variables['comment'] = $comment;
  $variables['comment_entity'] = $comment_entity;

  $account = comment_prepare_author($comment);
  $variables['author'] = theme('username', array('account' => $account));
  $variables['new'] = $comment->new->value ? t('new') : '';
  $variables['created'] = format_date($comment->created->value);
  // Avoid calling format_date() twice on the same timestamp.
  if ($comment->changed->value == $comment->created->value) {
    $variables['changed'] = $variables['created'];
  }
  else {
    $variables['changed'] = format_date($comment->changed->value);
  }

  if (theme_get_setting('toggle_comment_user_picture')) {
    // To change user picture settings (e.g., image style), edit the 'compact'
    // view mode on the User entity.
    $variables['user_picture'] = user_view($account, 'compact');
  }
  else {
    $variables['user_picture'] = array();
  }
  if (config('user.settings')->get('signatures') && !empty($account->signature)) {
    $variables['signature'] = check_markup($account->signature, $account->signature_format, '', TRUE) ;
  }
  else {
    $variables['signature'] = '';
  }

  $uri = $comment->uri();
  $uri['options'] += array('attributes' => array('class' => 'permalink', 'rel' => 'bookmark'));

  $variables['title'] = l($comment->subject->value, $uri['path'], $uri['options']);
  $variables['permalink'] = l(t('Permalink'), $uri['path'], $uri['options']);
  $variables['submitted'] = t('Submitted by !username on !datetime', array('!username' => $variables['author'], '!datetime' => $variables['created']));

  if ($comment->pid->target_id) {
    // Fetch and store the parent comment information for use in templates.
    $comment_parent = $comment->pid->entity;
    $account_parent = comment_prepare_author($comment);
    $variables['parent_comment'] = $comment_parent;
    $variables['parent_author'] = theme('username', array('account' => $account_parent));
    $variables['parent_created'] = format_date($comment_parent->created->value);
    // Avoid calling format_date() twice on the same timestamp.
    if ($comment_parent->changed->value == $comment_parent->created->value) {
      $variables['parent_changed'] = $variables['parent_created'];
    }
    else {
      $variables['parent_changed'] = format_date($comment_parent->changed->value);
    }
    $uri_parent = $comment_parent->uri();
    $uri_parent['options'] += array('attributes' => array('class' => 'permalink', 'rel' => 'bookmark'));
    $variables['parent_title'] = l($comment_parent->subject->value, $uri_parent['path'], $uri_parent['options']);
    $variables['parent_permalink'] = l(t('Parent permalink'), $uri_parent['path'], $uri_parent['options']);
    $variables['parent'] = t('In reply to !parent_title by !parent_username',
        array('!parent_username' => $variables['parent_author'], '!parent_title' => $variables['parent_title']));
  }
  else {
    $variables['parent_comment'] = '';
    $variables['parent_author'] = '';
    $variables['parent_created'] = '';
    $variables['parent_changed'] = '';
    $variables['parent_title'] = '';
    $variables['parent_permalink'] = '';
    $variables['parent'] = '';
  }

  // Preprocess fields.
  field_attach_preprocess($comment, $variables['elements'], $variables);

  // Helpful $content variable for templates.
  foreach (element_children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  // Set status to a string representation of comment->status.
  if (isset($comment->in_preview)) {
    $variables['status'] = 'preview';
  }
  else {
    $variables['status'] = ($comment->status->value == COMMENT_NOT_PUBLISHED) ? 'unpublished' : 'published';
  }

  // Gather comment classes.
  // 'published' class is not needed, it is either 'preview' or 'unpublished'.
  if ($variables['status'] != 'published') {
    $variables['attributes']['class'][] = $variables['status'];
  }
  if ($variables['new']) {
    $variables['attributes']['class'][] = 'new';
  }
  if (!$comment->uid->target_id) {
    $variables['attributes']['class'][] = 'by-anonymous';
  }
  else {
    if (($comment_entity instanceof EntityNG && !empty($comment_entity->uid->target_id) && $comment->uid->target_id == $comment_entity->uid->target_id) ||
        (!empty($comment_entity->uid) && $comment->uid->target_id == $comment_entity->uid)) {
      $variables['attributes']['class'][] = 'by-' . $comment_entity->entityType() . '-author';
    }
    if ($comment->uid->target_id == $variables['user']->uid) {
      $variables['attributes']['class'][] = 'by-viewer';
    }
  }
}

/**
 * Returns HTML for a "you can't post comments" notice.
 *
 * @param $variables
 *   An associative array containing:
 *   - entity: The comment entity.
 *
 * @ingroup themeable
 */
function theme_comment_post_forbidden($variables) {
  $entity = $variables['entity'];
  $field_name = $variables['field_name'];
  $instance = field_info_instance($entity->entityType(), $field_name, $entity->bundle());
  global $user;

  // Since this is expensive to compute, we cache it so that a page with many
  // comments only has to query the database once for all the links.
  $authenticated_post_comments = &drupal_static(__FUNCTION__, NULL);

  if (!$user->uid) {
    if (!isset($authenticated_post_comments)) {
      // We only output a link if we are certain that users will get permission
      // to post comments by logging in.
      $comment_roles = user_roles(TRUE, 'post comments');
      $authenticated_post_comments = isset($comment_roles[DRUPAL_AUTHENTICATED_RID]);
    }

    if ($authenticated_post_comments) {
      // We cannot use drupal_get_destination() because these links
      // sometimes appear on /node and taxonomy listing pages.
      if ($instance['settings']['form_location'] == COMMENT_FORM_SEPARATE_PAGE) {
        $destination = array('destination' => 'comment/reply/' . $entity->entityType() . '/' . $entity->id() . '/' . $field_name .'#comment-form');
      }
      else {
        $uri = $entity->uri();
        $destination = array('destination' => $uri['path'] . "#comment-form");
      }

      if (config('user.settings')->get('register') != USER_REGISTER_ADMINISTRATORS_ONLY) {
        // Users can register themselves.
        return t('<a href="@login">Log in</a> or <a href="@register">register</a> to post comments', array('@login' => url('user/login', array('query' => $destination)), '@register' => url('user/register', array('query' => $destination))));
      }
      else {
        // Only admins can add new users, no public registration.
        return t('<a href="@login">Log in</a> to post comments', array('@login' => url('user/login', array('query' => $destination))));
      }
    }
  }
}

/**
 * Preprocesses variables for comment-wrapper.tpl.php.
 *
 * @see comment-wrapper.tpl.php
 */
function template_preprocess_comment_wrapper(&$variables) {
  // Provide contextual information.
  $variables['entity'] = $variables['content']['#entity'];
  $variables['display_mode'] = $variables['content']['#display_mode'];
  // The comment form is optional and may not exist.
  $variables['content'] += array('comment_form' => array());
}

/**
 * Returns an array of viewing modes for comment listings.
 *
 * We can't use a global variable array because the locale system
 * is not initialized yet when the Comment module is loaded.
 */
function _comment_get_modes() {
  return array(
    COMMENT_MODE_FLAT => t('Flat list'),
    COMMENT_MODE_THREADED => t('Threaded list')
  );
}

/**
 * Returns an array of "comments per page" values that users can select from.
 */
function _comment_per_page() {
  return drupal_map_assoc(array(10, 30, 50, 70, 90, 150, 200, 250, 300));
}

/**
 * Generates a sorting code.
 *
 * Consists of a leading character indicating length, followed by N digits
 * with a numerical value in base 36 (alphadecimal). These codes can be sorted
 * as strings without altering numerical order.
 *
 * It goes:
 * 00, 01, 02, ..., 0y, 0z,
 * 110, 111, ... , 1zy, 1zz,
 * 2100, 2101, ..., 2zzy, 2zzz,
 * 31000, 31001, ...
 */
function comment_int_to_alphadecimal($i = 0) {
  $num = base_convert((int) $i, 10, 36);
  $length = strlen($num);

  return chr($length + ord('0') - 1) . $num;
}

/**
 * Decodes a sorting code back to an integer.
 *
 * @see comment_int_to_alphadecimal()
 */
function comment_alphadecimal_to_int($c = '00') {
  return base_convert(substr($c, 1), 36, 10);
}

/**
 * Implements hook_action_info().
 */
function comment_action_info() {
  return array(
    'comment_publish_action' => array(
      'label' => t('Publish comment'),
      'type' => 'comment',
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
      'triggers' => array('comment_presave', 'comment_insert', 'comment_update'),
    ),
    'comment_unpublish_action' => array(
      'label' => t('Unpublish comment'),
      'type' => 'comment',
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
      'triggers' => array('comment_presave', 'comment_insert', 'comment_update'),
    ),
    'comment_unpublish_by_keyword_action' => array(
      'label' => t('Unpublish comment containing keyword(s)'),
      'type' => 'comment',
      'configurable' => TRUE,
      'behavior' => array('changes_property'),
      'triggers' => array('comment_presave', 'comment_insert', 'comment_update'),
    ),
    'comment_save_action' => array(
      'label' => t('Save comment'),
      'type' => 'comment',
      'configurable' => FALSE,
      'triggers' => array('comment_insert', 'comment_update'),
    ),
  );
}

/**
 * Publishes a comment.
 *
 * @param \Drupal\comment\Plugin\Core\Entity\comment $comment
 *   (optional) A comment object to publish.
 * @param array $context
 *   Array with components:
 *   - 'cid': Comment ID. Required if $comment is not given.
 *
 * @ingroup actions
 */
function comment_publish_action(Comment $comment = NULL, $context = array()) {
  if (isset($comment->subject->value)) {
    $subject = $comment->subject->value;
    $comment->status->value = COMMENT_PUBLISHED;
  }
  else {
    $cid = $context['cid'];
    $subject = db_query('SELECT subject FROM {comment} WHERE cid = :cid', array(':cid' => $cid))->fetchField();
    db_update('comment')
      ->fields(array('status' => COMMENT_PUBLISHED))
      ->condition('cid', $cid)
      ->execute();
  }
  watchdog('action', 'Published comment %subject.', array('%subject' => $subject));
}

/**
 * Unpublishes a comment.
 *
 * @param \Drupal\comment\Plugin\Core\Entity\comment|null $comment
 *   (optional) A comment object to unpublish.
 * @param array $context
 *   Array with components:
 *   - 'cid': Comment ID. Required if $comment is not given.
 *
 * @ingroup actions
 */
function comment_unpublish_action(Comment $comment = NULL, $context = array()) {
  if (isset($comment->subject->value)) {
    $subject = $comment->subject->value;
    $comment->status->value = COMMENT_NOT_PUBLISHED;
  }
  else {
    $cid = $context['cid'];
    $subject = db_query('SELECT subject FROM {comment} WHERE cid = :cid', array(':cid' => $cid))->fetchField();
    db_update('comment')
      ->fields(array('status' => COMMENT_NOT_PUBLISHED))
      ->condition('cid', $cid)
      ->execute();
  }
  watchdog('action', 'Unpublished comment %subject.', array('%subject' => $subject));
}

/**
 * Unpublishes a comment if it contains certain keywords.
 *
 * @param \Drupal\comment\Plugin\Core\Entity\comment $comment
 *   Comment object to modify.
 * @param array $context
 *   Array with components:
 *   - 'keywords': Keywords to look for. If the comment contains at least one
 *     of the keywords, it is unpublished.
 *
 * @ingroup actions
 * @see comment_unpublish_by_keyword_action_form()
 * @see comment_unpublish_by_keyword_action_submit()
 */
function comment_unpublish_by_keyword_action(Comment $comment, $context) {
  $build = comment_view($comment);
  $text = drupal_render($build);
  foreach ($context['keywords'] as $keyword) {
    if (strpos($text, $keyword) !== FALSE) {
      $comment->status->value = COMMENT_NOT_PUBLISHED;
      watchdog('action', 'Unpublished comment %subject.', array('%subject' => $comment->subject->value));
      break;
    }
  }
}

/**
 * Form constructor for the blacklisted keywords form.
 *
 * @ingroup forms
 * @see comment_unpublish_by_keyword_action()
 * @see comment_unpublish_by_keyword_action_submit()
 */
function comment_unpublish_by_keyword_action_form($context) {
  $form['keywords'] = array(
    '#title' => t('Keywords'),
    '#type' => 'textarea',
    '#description' => t('The comment will be unpublished if it contains any of the phrases above. Use a case-sensitive, comma-separated list of phrases. Example: funny, bungee jumping, "Company, Inc."'),
    '#default_value' => isset($context['keywords']) ? drupal_implode_tags($context['keywords']) : '',
  );

  return $form;
}

/**
 * Form submission handler for comment_unpublish_by_keyword_action_form().
 *
 * @see comment_unpublish_by_keyword_action()
 */
function comment_unpublish_by_keyword_action_submit($form, $form_state) {
  return array('keywords' => drupal_explode_tags($form_state['values']['keywords']));
}

/**
 * Saves a comment.
 *
 * @param \Drupal\comment\Plugin\Core\Entity\comment $comment
 *
 * @ingroup actions
 */
function comment_save_action(Comment $comment) {
  comment_save($comment);
  cache_invalidate_tags(array('content' => TRUE));
  watchdog('action', 'Saved comment %title', array('%title' => $comment->subject->value));
}

/**
 * Implements hook_ranking().
 */
function comment_ranking() {
  return array(
    'comments' => array(
      'title' => t('Number of comments'),
      'join' => array(
        'type' => 'LEFT',
        'table' => 'comment_entity_statistics',
        'alias' => 'ces',
        // Default to comment field as this is the most common use case for
        // nodes.
        'on' => "ces.entity_id = i.sid AND ces.entity_type = 'node' AND ces.field_name = 'comment'",
      ),
      // Inverse law that maps the highest reply count on the site to 1 and 0 to 0.
      'score' => '2.0 - 2.0 / (1.0 + ces.comment_count * CAST(:scale AS DECIMAL))',
      'arguments' => array(':scale' => state()->get('comment.node_comment_statistics_scale') ?: 0),
    ),
  );
}

/**
 * Implements hook_rdf_mapping().
 */
function comment_rdf_mapping() {
  return array(
    array(
      'type' => 'comment',
      'bundle' => RDF_DEFAULT_BUNDLE,
      'mapping' => array(
        'rdftype' => array('sioc:Post', 'sioct:Comment'),
        'title' => array(
          'predicates' => array('dc:title'),
        ),
        'created' => array(
          'predicates' => array('dc:date', 'dc:created'),
          'datatype' => 'xsd:dateTime',
          'callback' => 'date_iso8601',
        ),
        'changed' => array(
          'predicates' => array('dc:modified'),
          'datatype' => 'xsd:dateTime',
          'callback' => 'date_iso8601',
        ),
        'comment_body' => array(
          'predicates' => array('content:encoded'),
        ),
        'pid' => array(
          'predicates' => array('sioc:reply_of'),
          'type' => 'rel',
        ),
        'uid' => array(
          'predicates' => array('sioc:has_creator'),
          'type' => 'rel',
        ),
        'name' => array(
          'predicates' => array('foaf:name'),
        ),
      ),
    ),
  );
}

/**
 * Implements hook_file_download_access().
 */
function comment_file_download_access($field, EntityInterface $entity, File $file) {
  if ($entity->entityType() == 'comment') {
    if (user_access('access comments') && $entity->status->value == COMMENT_PUBLISHED || user_access('administer comments')) {
      $commented_entity = entity_load($entity->entity_type->value, $entity->entity_id->target_id);
      // Check access to parent entity.
      return comment_reply_access($commented_entity);
    }
    return FALSE;
  }
}

/**
 * Implements hook_library_info().
 */
function comment_library_info() {
  $libraries['drupal.comment'] = array(
    'title' => 'Comment',
    'version' => VERSION,
    'js' => array(
      drupal_get_path('module', 'comment') . '/comment-entity-form.js' => array(),
    ),
    'dependencies' => array(
      array('system', 'jquery'),
      array('system', 'drupal'),
      array('system', 'drupal.form'),
    ),
  );

  return $libraries;
}

/**
 * Utility function to return an array of comment fields.
 *
 * @param string $entity_type
 *   (optional) Specify a entity type if you want to just return fields which
 *   are attached on a certain entity type. Defaults to NULL.
 *
 * @return array
 *   An array of comment field map definitions, keyed by field name. Each value
 *   is an array with two entries:
 *   - type: The field type.
 *   - bundles: The bundles in which the field appears, as an array with entity
 *     types as keys and the array of bundle names as values.
 *
 * @see field_info_field_map().
 */
function comment_get_comment_fields($entity_type = NULL) {
  return array_filter(field_info_field_map(), function ($value) use($entity_type) {
    if ($value['type']  == 'comment') {
      if (isset($entity_type)) {
        return isset($value['bundles'][$entity_type]);
      }
      return TRUE;
    }
  });
}

/**
 * Decide on the type of marker to be shown for a comment.
 *
 * @param Comment $comment
 *   The comment for which the marker is to be shown.
 *
 * @return int
 *   The type of marker to be shown one of MARK_READ, MARK_UPDATED or MARK_NEW.
 */
function comment_mark(Comment $comment) {
  global $user;
  $cache = &drupal_static(__FUNCTION__, array());
  $cid = $comment->entity_id->target_id . '__' . $comment->entity_type->value;

  if (!$user->uid) {
    return MARK_READ;
  }
  if (!isset($cache[$cid])) {
    if ($comment->entity_type->value == 'node' && module_exists('history')) {
      $cache[$cid] = history_read($comment->entity_id->target_id);
    }
    else {
      // @todo - decide how to handle last viewed for other entities. For now
      // assume REQUEST_TIME.
      $cache[$cid] = REQUEST_TIME;
    }
  }
  if ($cache[$cid] == 0 && $comment->changed->value > COMMENT_NEW_LIMIT) {
    return MARK_NEW;
  }
  elseif ($comment->changed->value > $cache[$cid] && $comment->changed->value > COMMENT_NEW_LIMIT) {
    return MARK_UPDATED;
  }
  return MARK_READ;
}

/**
 * Utility method to add the default comment field to an entity.
 *
 * Attaches a comment field named 'comment' to the given entity type and bundle.
 * Largely replicates the default behaviour in Drupal 7 and earlier.
 *
 * @param string $entity_type
 *   The entity type to attach the default comment field to.
 * @param string $bundle
 *   The bundle to attach the default comment field instance to.
 * @param string $field_name
 *   (optional) Field name to use for the comment field. Defaults to 'comment'.
 * @param string $default_value
 *   (optional) Default value, one of COMMENT_HIDDEN, COMMENT_OPEN,
 *   COMMENT_CLOSED. Defaults to COMMENT_OPEN.
 */
function comment_add_default_comment_field($entity_type, $bundle, $field_name = 'comment', $default_value = COMMENT_OPEN) {
  // Make sure field doesn't already exist.
  if (!field_info_field($field_name)) {
    // Add a default comment field for existing node comments.
    $field = array(
      'field_name' => $field_name,
      'type' => 'comment',
      'translatable' => '0',
    );
    // Create the field.
    field_create_field($field);
  }
  // Make sure the instance doesn't already exist.
  if (!field_info_instance($entity_type, $field_name, $bundle)) {
    $instance = array(
      'label' => 'Comment settings',
      'description' => '',
      'field_name' => $field_name,
      'entity_type' => $entity_type,
      'bundle' => $bundle,
      'required' => 1,
      'default_value' => array(array('status' => $default_value)),
      'widget' => array(
        'type' => 'comment_default',
        'weight' => '50',
      ),
    );
    field_create_instance($instance);

    // Set default to display comment list.
    entity_get_display($entity_type, $bundle, 'default')
      ->setComponent($field_name, array(
        'label' => 'hidden',
        'type' => 'comment_default',
        'weight' => 1,
      ))
      ->save();
  }
  _comment_body_field_create($entity_type, $bundle, $field_name);
}

/**
 * Implements hook_field_create_instance().
 */
function comment_field_create_instance($instance) {
  $field = field_info_field($instance['field_name']);
  if ($field['type'] == 'comment') {
    _comment_body_field_create($instance['entity_type'], $instance['bundle'], $instance['field_name']);
    cache()->delete('comment_entity_info');
  }
}

/**
 * Implements hook_field_delete_instance().
 */
function comment_field_delete_instance($instance) {
  $field = field_info_field($instance['field_name']);
  if ($field['type'] == 'comment') {
    // Delete all fields and displays attached to the bundle.
    field_attach_delete_bundle('comment', $instance['field_name']);
    cache()->delete('comment_entity_info');
  }
}

/**
 * Helper to get default value for field.
 *
 * @param array $values
 *   The field values array or NULL for field create with field UI.
 *
 * @return int
 *   The value when exists or COMMENT_OPEN.
 *
 * @todo Replace with field default value after http://drupal.org/node/1919834
 */
function _comment_get_default_status($values) {
  // We only ever process first value if any.
  return isset($values[0]['status']) ? $values[0]['status'] : COMMENT_OPEN;
}
