<?php

/**
 * @file
 * Install, update and uninstall functions for the taxonomy module.
 */

use Drupal\Component\Uuid\Uuid;

/**
 * Implements hook_uninstall().
 */
function taxonomy_uninstall() {
  // Remove taxonomy_term bundles.
  $config_names = config_get_storage_names_with_prefix('taxonomy.vocabulary.');
  foreach ($config_names as $config_name) {
    $vid = substr($config_name, strlen('taxonomy.vocabulary.'));
    entity_invoke_bundle_hook('delete', 'taxonomy_term', $vid);
  }
}

/**
 * Implements hook_schema().
 */
function taxonomy_schema() {
  $schema['taxonomy_term_data'] = array(
    'description' => 'Stores term information.',
    'fields' => array(
      'tid' => array(
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'description' => 'Primary Key: Unique term ID.',
      ),
      'uuid' => array(
        'description' => 'Unique Key: Universally unique identifier for this entity.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => FALSE,
      ),
      'vid' => array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
        'description' => 'The ID of the vocabulary to which the term is assigned.',
      ),
      'langcode' => array(
        'description' => 'The {language}.langcode of this term.',
        'type' => 'varchar',
        'length' => 12,
        'not null' => TRUE,
        'default' => '',
      ),
      'name' => array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
        'description' => 'The term name.',
      ),
      'weight' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The weight of this term in relation to other terms.',
      ),
    ),
    'primary key' => array('tid'),
    'unique keys' => array(
      'uuid' => array('uuid'),
    ),
    'indexes' => array(
      'taxonomy_tree' => array(array('vid', 64), 'weight', 'name'),
      'vid_name' => array(array('vid', 64), 'name'),
      'name' => array('name'),
    ),
  );

  $schema['taxonomy_term_hierarchy'] = array(
    'description' => 'Stores the hierarchical relationship between terms.',
    'fields' => array(
      'tid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'Primary Key: The {taxonomy_term_data}.tid of the term.',
      ),
      'parent' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => "Primary Key: The {taxonomy_term_data}.tid of the term's parent. 0 indicates no parent.",
      ),
    ),
    'indexes' => array(
      'parent' => array('parent'),
    ),
    'foreign keys' => array(
      'taxonomy_term_data' => array(
        'table' => 'taxonomy_term_data',
        'columns' => array('tid' => 'tid'),
      ),
    ),
    'primary key' => array('tid', 'parent'),
  );

  $schema['taxonomy_index'] = array(
    'description' => 'Maintains denormalized information about node/term relationships.',
    'fields' => array(
      'nid' => array(
        'description' => 'The {node}.nid this record tracks.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'tid' => array(
         'description' => 'The term ID.',
         'type' => 'int',
         'unsigned' => TRUE,
         'not null' => TRUE,
         'default' => 0,
      ),
      'sticky' => array(
        'description' => 'Boolean indicating whether the node is sticky.',
        'type' => 'int',
        'not null' => FALSE,
        'default' => 0,
        'size' => 'tiny',
      ),
      'created' => array(
        'description' => 'The Unix timestamp when the node was created.',
        'type' => 'int',
        'not null' => TRUE,
        'default'=> 0,
      ),
    ),
    'indexes' => array(
      'term_node' => array('tid', 'sticky', 'created'),
      'nid' => array('nid'),
    ),
    'foreign keys' => array(
      'tracked_node' => array(
        'table' => 'node',
        'columns' => array('nid' => 'nid'),
      ),
      'term' => array(
        'table' => 'taxonomy_term_data',
        'columns' => array('tid' => 'tid'),
      ),
    ),
  );

  return $schema;
}

/**
 * Implements hook_field_schema().
 */
function taxonomy_field_schema($field) {
  return array(
    'columns' => array(
      'tid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
      ),
    ),
    'indexes' => array(
      'tid' => array('tid'),
    ),
    'foreign keys' => array(
      'tid' => array(
        'table' => 'taxonomy_term_data',
        'columns' => array('tid' => 'tid'),
      ),
    ),
  );
}

/**
 * Implements hook_update_dependencies().
 */
function taxonomy_update_dependencies() {
  // Convert term description to a field before fields are convert to config.
  $dependencies['field'][8003] = array(
    'taxonomy' => 8009,
  );
  return $dependencies;
}

/**
 * Remove the {taxonomy_vocabulary}.module field.
 */
function taxonomy_update_8000() {
  db_drop_field('taxonomy_vocabulary', 'module');
}

/**
 * Adds langcode field to {taxonomy_term_data} and {taxonomy_vocabulary}.
 *
 * @see http://drupal.org/node/1454538
 */
function taxonomy_update_8001() {
  $descriptions = array(
    'taxonomy_term_data' => 'The {language}.langcode of this term.',
    'taxonomy_vocabulary' => 'The {language}.langcode of this vocabulary.',
  );
  foreach ($descriptions as $table => $description) {
    $langcode_field = array(
      'description' => $description,
      'type' => 'varchar',
      'length' => 12,
      'not null' => TRUE,
      'default' => '',
    );

    // If a Drupal 7 contrib module already added a langcode field to support
    // internationalization, keep it, but standardize the specification.
    // Otherwise, add the field.
    if (db_field_exists($table, 'langcode')) {
      // According to the documentation of db_change_field(), indices using the
      // field should be dropped first; if the contrib module created any
      // indices, it is its responsibility to drop them in an update function
      // that runs before this one, which it can enforce via
      // hook_update_dependencies().
      db_change_field($table, 'langcode', 'langcode', $langcode_field);
    }
    else {
      // When updating from a site that did not already have taxonomy
      // internationalization, initialize all existing vocabularies and terms as
      // being in the site's default language.
      $langcode_field['initial'] = language_default()->langcode;
      db_add_field($table, 'langcode', $langcode_field);
    }
  }
}

/**
 * Create a UUID column for taxonomy terms.
 */
function taxonomy_update_8002() {
  $spec = array(
    'description' => 'Unique Key: Universally unique identifier for this entity.',
    'type' => 'varchar',
    'length' => 128,
    'not null' => FALSE,
  );
  $keys = array(
    'unique keys' => array(
      'uuid' => array('uuid'),
    ),
  );
  // Account for sites having the contributed UUID module installed.
  if (db_field_exists('taxonomy_term_data', 'uuid')) {
    db_change_field('taxonomy_term_data', 'uuid', 'uuid', $spec, $keys);
  }
  else {
    db_add_field('taxonomy_term_data', 'uuid', $spec, $keys);
  }
}

/**
 * Generate a UUID for all terms.
 */
function taxonomy_update_8003(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['last'] = 0;
    $sandbox['max'] = db_query('SELECT COUNT(tid) FROM {taxonomy_term_data} WHERE uuid IS NULL')->fetchField();
  }

  $tids = db_query_range('SELECT tid FROM {taxonomy_term_data} WHERE tid > :tid AND uuid IS NULL ORDER BY tid ASC', 0, 10, array(':tid' => $sandbox['last']))->fetchCol();
  update_add_uuids($sandbox, 'taxonomy_term_data', 'tid', $tids);

  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress'] / $sandbox['max']);
}

/**
 * Moves taxonomy settings from variable to config.
 */
function taxonomy_update_8004() {
  update_variables_to_config('taxonomy.settings', array(
    'taxonomy_override_selector' => 'override_selector',
    'taxonomy_terms_per_page_admin' => 'terms_per_page_admin',
    'taxonomy_maintain_index_table' => 'maintain_index_table',
  ));
}

/**
 * Convert vocabularies into configuration.
 */
function taxonomy_update_8005() {
  $uuid = new Uuid();

  $result = db_query('SELECT * FROM {taxonomy_vocabulary}');
  foreach ($result as $vocabulary) {
    $config = config('taxonomy.vocabulary.' . $vocabulary->machine_name)
      ->set('vid', $vocabulary->machine_name)
      ->set('name', $vocabulary->name)
      ->set('uuid', !empty($vocabulary->uuid) ? $vocabulary->uuid : $uuid->generate())
      ->set('description', $vocabulary->description)
      ->set('hierarchy', $vocabulary->hierarchy)
      ->set('weight', $vocabulary->weight)
      ->set('langcode', $vocabulary->langcode)
      ->save();
  }
}

/**
 * Change {taxonomy_term_data}.vid into a string holding the vocabulary machine name.
 */
function taxonomy_update_8006() {
  db_drop_index('taxonomy_term_data', 'taxonomy_tree');
  db_drop_index('taxonomy_term_data', 'vid_name');
  db_change_field('taxonomy_term_data', 'vid', 'vid', array(
    'type' => 'varchar',
    'length' => 255,
    'not null' => TRUE,
    'default' => '',
    'description' => 'The ID of the vocabulary to which the term is assigned.',
  ));
  db_add_index('taxonomy_term_data', 'taxonomy_tree', array(array('vid', 64), 'weight', 'name'));
  db_add_index('taxonomy_term_data', 'vid_name', array(array('vid', 64), 'name'));

  $map = db_query('SELECT vid, machine_name FROM {taxonomy_vocabulary}')->fetchAllKeyed();
  foreach ($map as $vid => $machine_name) {
    db_update('taxonomy_term_data')
      ->condition('vid', $vid)
      ->fields(array('vid' => $machine_name))
      ->execute();
  }
}

/**
 * Create new field for term descriptions.
 */
function taxonomy_update_8007() {
  $vocabularies = config_get_storage_names_with_prefix('taxonomy.vocabulary.');
  if (count($vocabularies)) {
    // Create a new term description field.
    $field = array(
      'field_name' => 'taxonomy_term_description',
      'module' => 'text',
      'type' => 'text_long',
      'cardinality' => 1,
      'locked' => FALSE,
      'storage' => array(
        'type' => 'field_sql_storage',
        'settings' => array(),
      ),
    );
    _update_7000_field_create_field($field);

    // Create instances for existing vocabularies.
    foreach ($vocabularies as $vocabulary) {
      $vocabulary = substr($vocabulary, strlen('taxonomy.vocabulary.'));
      // Attaches the description field to each bundle.
      $instance = array(
        'field_name' => 'taxonomy_term_description',
        'label' => 'Description',
        'description' => '',
        'entity_type' => 'taxonomy_term',
        'bundle' => $vocabulary,
        'required' => FALSE,
        'settings' => array('text_processing' => 1),
        'widget' => array(
          'type' => 'text_textarea',
          'module' => 'text',
          'settings' => array(
            'rows' => 5,
          ),
        ),
        'display' => array(
          'default' => array(
            'label' => 'hidden',
            'type' => 'text_default',
          ),
        ),
      );
      _update_7000_field_create_instance($field, $instance);
    }
  }
}

/**
 * Move term descriptions in {term_data}.description into new field.
 */
function taxonomy_update_8008(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['current_tid'] = 0;
    $sandbox['max'] = db_query('SELECT COUNT(DISTINCT tid) FROM {taxonomy_term_data} WHERE vid > 0')->fetchField();
  }

  $terms = db_query_range('SELECT t.tid, t.description, t.format, t.vid FROM {taxonomy_term_data} t WHERE tid > :tid ORDER BY tid ASC', 0, 100, array(':tid' => $sandbox['current_tid']));

  $data = db_insert('field_data_taxonomy_term_description')
    ->fields(array('entity_type', 'bundle', 'entity_id', 'revision_id', 'langcode', 'delta', 'taxonomy_term_description_value', 'taxonomy_term_description_format'));
  $revision = db_insert('field_revision_taxonomy_term_description')
    ->fields(array('entity_type', 'bundle', 'entity_id', 'revision_id', 'langcode', 'delta', 'taxonomy_term_description_value', 'taxonomy_term_description_format'));
  foreach ($terms as $term) {
    $data->values(array(
        'entity_type' => 'taxonomy_term',
        'bundle' => $term->vid,
        'entity_id' => $term->tid,
        'revision_id' => $term->tid,
        'langcode' => LANGUAGE_NOT_SPECIFIED,
        'delta' => 0,
        'taxonomy_term_description_value' => $term->description,
        'taxonomy_term_description_format' => $term->format,
      ));
    $revision->fields(array(
        'entity_type' => 'taxonomy_term',
        'bundle' => $term->vid,
        'entity_id' => $term->tid,
        'revision_id' => $term->tid,
        'langcode' => LANGUAGE_NOT_SPECIFIED,
        'delta' => 0,
        'taxonomy_term_description_value' => $term->description,
        'taxonomy_term_description_format' => $term->format,
      ));
    $sandbox['progress']++;
    $sandbox['current_tid'] = $term->tid;
  }

  $data->execute();
  $revision->execute();

  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress'] / $sandbox['max']);
}

/**
 * Remove {term_data}.description and {term_data}.format.
 */
function taxonomy_update_8009() {
  db_drop_field('taxonomy_term_data', 'description');
  db_drop_field('taxonomy_term_data', 'format');
}
