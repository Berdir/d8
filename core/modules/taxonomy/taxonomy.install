<?php

/**
 * @file
 * Install, update and uninstall functions for the taxonomy module.
 */

use Drupal\Component\Utility\NestedArray;
use Drupal\Component\Uuid\Uuid;

/**
 * Implements hook_uninstall().
 */
function taxonomy_uninstall() {
  // Remove taxonomy_term bundles.
  $config_names = config_get_storage_names_with_prefix('taxonomy.vocabulary.');
  foreach ($config_names as $config_name) {
    $vid = substr($config_name, strlen('taxonomy.vocabulary.'));
    field_attach_delete_bundle('taxonomy_term', $vid);
  }
}

/**
 * Implements hook_schema().
 */
function taxonomy_schema() {
  $schema['taxonomy_term_data'] = array(
    'description' => 'Stores term information.',
    'fields' => array(
      'tid' => array(
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'description' => 'Primary Key: Unique term ID.',
      ),
      'uuid' => array(
        'description' => 'Unique Key: Universally unique identifier for this entity.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => FALSE,
      ),
      'vid' => array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
        'description' => 'The ID of the vocabulary to which the term is assigned.',
      ),
      'langcode' => array(
        'description' => 'The {language}.langcode of this term.',
        'type' => 'varchar',
        'length' => 12,
        'not null' => TRUE,
        'default' => '',
      ),
      'name' => array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
        'description' => 'The term name.',
      ),
      'description' => array(
        'type' => 'text',
        'not null' => FALSE,
        'size' => 'big',
        'description' => 'A description of the term.',
      ),
      'format' => array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE,
        'description' => 'The filter format ID of the description.',
      ),
      'weight' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' => 'The weight of this term in relation to other terms.',
      ),
    ),
    'primary key' => array('tid'),
    'unique keys' => array(
      'uuid' => array('uuid'),
    ),
    'indexes' => array(
      'taxonomy_tree' => array(array('vid', 64), 'weight', 'name'),
      'vid_name' => array(array('vid', 64), 'name'),
      'name' => array('name'),
    ),
  );

  $schema['taxonomy_term_hierarchy'] = array(
    'description' => 'Stores the hierarchical relationship between terms.',
    'fields' => array(
      'tid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'Primary Key: The {taxonomy_term_data}.tid of the term.',
      ),
      'parent' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => "Primary Key: The {taxonomy_term_data}.tid of the term's parent. 0 indicates no parent.",
      ),
    ),
    'indexes' => array(
      'parent' => array('parent'),
    ),
    'foreign keys' => array(
      'taxonomy_term_data' => array(
        'table' => 'taxonomy_term_data',
        'columns' => array('tid' => 'tid'),
      ),
    ),
    'primary key' => array('tid', 'parent'),
  );

  $schema['taxonomy_index'] = array(
    'description' => 'Maintains denormalized information about node/term relationships.',
    'fields' => array(
      'nid' => array(
        'description' => 'The {node}.nid this record tracks.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'tid' => array(
         'description' => 'The term ID.',
         'type' => 'int',
         'unsigned' => TRUE,
         'not null' => TRUE,
         'default' => 0,
      ),
      'sticky' => array(
        'description' => 'Boolean indicating whether the node is sticky.',
        'type' => 'int',
        'not null' => FALSE,
        'default' => 0,
        'size' => 'tiny',
      ),
      'created' => array(
        'description' => 'The Unix timestamp when the node was created.',
        'type' => 'int',
        'not null' => TRUE,
        'default'=> 0,
      ),
    ),
    'indexes' => array(
      'term_node' => array('tid', 'sticky', 'created'),
      'nid' => array('nid'),
    ),
    'foreign keys' => array(
      'tracked_node' => array(
        'table' => 'node',
        'columns' => array('nid' => 'nid'),
      ),
      'term' => array(
        'table' => 'taxonomy_term_data',
        'columns' => array('tid' => 'tid'),
      ),
    ),
  );

  return $schema;
}

/**
 * Implements hook_field_schema().
 */
function taxonomy_field_schema($field) {
  return array(
    'columns' => array(
      'tid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
      ),
    ),
    'indexes' => array(
      'tid' => array('tid'),
    ),
    'foreign keys' => array(
      'tid' => array(
        'table' => 'taxonomy_term_data',
        'columns' => array('tid' => 'tid'),
      ),
    ),
  );
}

/**
 * Remove the {taxonomy_vocabulary}.module field.
 */
function taxonomy_update_8000() {
  db_drop_field('taxonomy_vocabulary', 'module');
}

/**
 * Adds langcode field to {taxonomy_term_data} and {taxonomy_vocabulary}.
 *
 * @see http://drupal.org/node/1454538
 */
function taxonomy_update_8001() {
  $descriptions = array(
    'taxonomy_term_data' => 'The {language}.langcode of this term.',
    'taxonomy_vocabulary' => 'The {language}.langcode of this vocabulary.',
  );
  foreach ($descriptions as $table => $description) {
    $langcode_field = array(
      'description' => $description,
      'type' => 'varchar',
      'length' => 12,
      'not null' => TRUE,
      'default' => '',
    );

    // If a Drupal 7 contrib module already added a langcode field to support
    // internationalization, keep it, but standardize the specification.
    // Otherwise, add the field.
    if (db_field_exists($table, 'langcode')) {
      // According to the documentation of db_change_field(), indices using the
      // field should be dropped first; if the contrib module created any
      // indices, it is its responsibility to drop them in an update function
      // that runs before this one, which it can enforce via
      // hook_update_dependencies().
      db_change_field($table, 'langcode', 'langcode', $langcode_field);
    }
    else {
      // When updating from a site that did not already have taxonomy
      // internationalization, initialize all existing vocabularies and terms as
      // being in the site's default language.
      $langcode_field['initial'] = language_default()->langcode;
      db_add_field($table, 'langcode', $langcode_field);
    }
  }
}

/**
 * Create a UUID column for taxonomy terms.
 */
function taxonomy_update_8002() {
  $spec = array(
    'description' => 'Unique Key: Universally unique identifier for this entity.',
    'type' => 'varchar',
    'length' => 128,
    'not null' => FALSE,
  );
  $keys = array(
    'unique keys' => array(
      'uuid' => array('uuid'),
    ),
  );
  // Account for sites having the contributed UUID module installed.
  if (db_field_exists('taxonomy_term_data', 'uuid')) {
    db_change_field('taxonomy_term_data', 'uuid', 'uuid', $spec, $keys);
  }
  else {
    db_add_field('taxonomy_term_data', 'uuid', $spec, $keys);
  }
}

/**
 * Generate a UUID for all terms.
 */
function taxonomy_update_8003(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['last'] = 0;
    $sandbox['max'] = db_query('SELECT COUNT(tid) FROM {taxonomy_term_data} WHERE uuid IS NULL')->fetchField();
  }

  $tids = db_query_range('SELECT tid FROM {taxonomy_term_data} WHERE tid > :tid AND uuid IS NULL ORDER BY tid ASC', 0, 10, array(':tid' => $sandbox['last']))->fetchCol();
  update_add_uuids($sandbox, 'taxonomy_term_data', 'tid', $tids);

  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress'] / $sandbox['max']);
}

/**
 * Moves taxonomy settings from variable to config.
 */
function taxonomy_update_8004() {
  update_variables_to_config('taxonomy.settings', array(
    'taxonomy_override_selector' => 'override_selector',
    'taxonomy_terms_per_page_admin' => 'terms_per_page_admin',
    'taxonomy_maintain_index_table' => 'maintain_index_table',
  ));
}

/**
 * Convert vocabularies into configuration.
 */
function taxonomy_update_8005() {
  $uuid = new Uuid();

  $result = db_query('SELECT * FROM {taxonomy_vocabulary}');
  foreach ($result as $vocabulary) {
    $config = config('taxonomy.vocabulary.' . $vocabulary->machine_name)
      ->set('vid', $vocabulary->machine_name)
      ->set('name', $vocabulary->name)
      ->set('uuid', !empty($vocabulary->uuid) ? $vocabulary->uuid : $uuid->generate())
      ->set('description', $vocabulary->description)
      ->set('hierarchy', $vocabulary->hierarchy)
      ->set('weight', $vocabulary->weight)
      ->set('langcode', $vocabulary->langcode)
      ->save();
  }
}

/**
 * Change {taxonomy_term_data}.vid into a string holding the vocabulary machine name.
 */
function taxonomy_update_8006() {
  db_drop_index('taxonomy_term_data', 'taxonomy_tree');
  db_drop_index('taxonomy_term_data', 'vid_name');
  db_change_field('taxonomy_term_data', 'vid', 'vid', array(
    'type' => 'varchar',
    'length' => 255,
    'not null' => TRUE,
    'default' => '',
    'description' => 'The ID of the vocabulary to which the term is assigned.',
  ));
  db_add_index('taxonomy_term_data', 'taxonomy_tree', array(array('vid', 64), 'weight', 'name'));
  db_add_index('taxonomy_term_data', 'vid_name', array(array('vid', 64), 'name'));

  $map = db_query('SELECT vid, machine_name FROM {taxonomy_vocabulary}')->fetchAllKeyed();
  foreach ($map as $vid => $machine_name) {
    db_update('taxonomy_term_data')
      ->condition('vid', $vid)
      ->fields(array('vid' => $machine_name))
      ->execute();
  }
}

/**
 * Convert taxonomy term fields to entity reference.
 */
function taxonomy_update_8007() {
  if (!$fields = field_read_fields(array('type' => 'taxonomy_term_reference'), array('include_inactive' => 1))) {
    return;
  }
  update_module_enable(array('entity_reference'));
  module_load_install('entity_reference');

  foreach ($fields as $field_name => $field) {
    if ($field['storage']['type'] != 'field_sql_storage') {
      // Field doesn't use SQL storage, we cannot modify the schema.
      continue;
    }

    $instances = field_read_instances(array('field_id' => $field['id']), array('include_inactive' => 1));

    $tables = array(
      _field_sql_storage_tablename($field),
      _field_sql_storage_revision_tablename($field),
    );

    foreach ($tables as $table_name) {
      db_change_field($table_name, $field_name . '_tid', $field_name . '_target_id', array(
        'description' => 'The ID of the target entity.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ));

      // Add the revision ID column.
      $column = array(
        'description' => 'The revision ID of the target entity.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
      );
      db_add_field($table_name, $field_name . '_revision_id', $column);

      // Change the index.
      db_drop_index($table_name, $field_name . '_tid');
      db_add_index($table_name, $field_name . '_target_id', array($field_name . '_target_id'));
    }

    // Update the field settings.
    $field['settings']['target_type'] = 'taxonomy_term';
    $schema = entity_reference_field_schema($field);
    unset($field['columns'], $field['indexes'], $field['foreign keys']);
    $field = NestedArray::mergeDeep($field, $schema);

    // @todo: Bring back $field['settings']['allowed_values'][0]['parent'] in
    // http://drupal.org/node/1915056.
    $vocabulary_name = $field['settings']['allowed_values'][0]['vocabulary'];
    unset($field['settings']['allowed_values']);

    $field['module'] = $field['type'] = 'entity_reference';

    _update_7000_field_update_field($field);

    // Update the instance settings.
    if (!$instances) {
      continue;
    }

    $field = field_info_field($field_name);

    foreach ($instances as $instance) {
      if ($instance['widget']['type'] == 'taxonomy_autocomplete') {
        // Update the widget.
        $instance['widget']['type'] = 'entity_reference_autocomplete_tags';
        $instance['widget']['module'] = 'entity_reference';
        $instance['widget']['settings']['match_operator'] = "CONTAINS";
        $instance['widget']['settings']['autocomplete_path'] = "entity_reference/autocomplete/tags";
      }

      $instance['settings']['handler'] = 'default';
      $instance['settings']['handler_settings'] = array(
        'target_bundles' => array($vocabulary_name),
        // Enable auto-create.
        'auto_create' => TRUE,
      );

      _update_7000_field_update_instance($field, $instance);

      if (empty($field['bundles'])) {
        continue;
      }

      // Update the formatter.
      foreach ($field['bundles'] as $entity_type => $bundles) {
        $entity_info = drupal_container()->get('plugin.manager.entity')->getDefinition($entity_type);
        foreach ($bundles as $bundle) {
          // Add the 'default' view mode.
          $entity_info['view_modes'][] = 'default';
          foreach (array_keys($entity_info['view_modes']) as $view_mode) {
            $display = _update_8000_entity_get_display($entity_type, $bundle, $view_mode);
            $original_display = $display->get('content.' . $field_name);
            $display->set('content.' . $field_name, array(
                'label' => $original_display['label'],
                'weight' => $original_display['weight'],
                'type' => 'entity_reference_label',
                'settings' => array('link' => TRUE),
              ))
              ->save();
            update_config_manifest_add('entity.display', array($display->get('id')));
          }
        }
      }
    }
  }
}
