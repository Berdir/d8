<?php

/**
 * @file
 * Default implementation of the field storage API.
 */

use Drupal\Core\Database\Database;
use Drupal\Core\Entity\EntityInterface;
use Drupal\field\FieldUpdateForbiddenException;
use Drupal\field\Plugin\Core\Entity\Field;

/**
 * Implements hook_help().
 */
function field_sql_storage_help($path, $arg) {
  switch ($path) {
    case 'admin/help#field_sql_storage':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Field SQL Storage module stores field data in the database. It is the default field storage module; other field storage mechanisms may be available as contributed modules. See the <a href="@field-help">Field module help page</a> for more information about fields.', array('@field-help' => url('admin/help/field'))) . '</p>';
      return $output;
  }
}

/**
 * Implements hook_field_storage_info().
 */
function field_sql_storage_field_storage_info() {
  return array(
    'field_sql_storage' => array(
      'label' => t('Default SQL storage'),
      'description' => t('Stores fields in the local SQL database, using per-field tables.'),
    ),
  );
}

/**
 * Generates a table name for a field data table.
 *
 * When a field is a deleted, the table is renamed to
 * {field_deleted_data_FIELD_UUID}. To make sure we don't end up with table
 * names longer than 64 characters, we hash the uuid and return the first 10
 * characters so we end up with a short unique ID.
 *
 * @param $field
 *   The field structure.
 *
 * @return
 *   A string containing the generated name for the database table.
 */
function _field_sql_storage_tablename($field) {
  if ($field['deleted']) {
    return "field_deleted_data_" . substr(hash('sha256', $field['uuid']), 0, 10);
  }
  else {
    return "field_data_{$field['field_name']}";
  }
}

/**
 * Generates a table name for a field revision archive table.
 *
 * When a field is a deleted, the table is renamed to
 * {field_deleted_revision_FIELD_UUID}. To make sure we don't end up with table
 * names longer than 64 characters, we hash the uuid and return the first
 * 10 characters so we end up with a short unique ID.
 *
 * @param $name
 *   The field structure.
 *
 * @return
 *   A string containing the generated name for the database table.
 */
function _field_sql_storage_revision_tablename($field) {
  if ($field['deleted']) {
    return "field_deleted_revision_" . substr(hash('sha256', $field['uuid']), 0, 10);
  }
  else {
    return "field_revision_{$field['field_name']}";
  }
}

/**
 * Generates a column name for a field data table.
 *
 * @param $name
 *   The name of the field.
 * @param $column
 *   The name of the column.
 *
 * @return
 *   A string containing a generated column name for a field data table that is
 *   unique among all other fields.
 */
function _field_sql_storage_columnname($name, $column) {
  return in_array($column, Field::getReservedColumns()) ? $column : $name . '_' . $column;
}

/**
 * Generates an index name for a field data table.
 *
 * @param $name
 *   The name of the field.
 * @param $column
 *   The name of the index.
 *
 * @return
 *   A string containing a generated index name for a field data table that is
 *   unique among all other fields.
 */
function _field_sql_storage_indexname($name, $index) {
  return $name . '_' . $index;
}

/**
 * Returns the database schema for a field.
 *
 * This may contain one or more tables. Each table will contain the columns
 * relevant for the specified field. Leave the $field's 'columns' and 'indexes'
 * keys empty to get only the base schema.
 *
 * @param $field
 *   The field structure for which to generate a database schema.
 * @return
 *   One or more tables representing the schema for the field.
 */
function _field_sql_storage_schema($field) {
}

/**
 * Implements hook_field_update_forbid().
 *
 * Forbids any field update that changes column definitions if there is any
 * data.
 */
function field_sql_storage_field_update_forbid($field, $prior_field) {
  if ($field->hasData() && $field['columns'] != $prior_field['columns']) {
    throw new FieldUpdateForbiddenException("field_sql_storage cannot change the schema for an existing field with data.");
  }
}

/**
 * Implements hook_field_storage_update_field().
 */
function field_sql_storage_field_storage_update_field($field, $prior_field) {
  if (!$field->hasData()) {
    // There is no data. Re-create the tables completely.

    if (Database::getConnection()->supportsTransactionalDDL()) {
      // If the database supports transactional DDL, we can go ahead and rely
      // on it. If not, we will have to rollback manually if something fails.
      $transaction = db_transaction();
    }

    try {
      $prior_schema = _field_sql_storage_schema($prior_field);
      foreach ($prior_schema as $name => $table) {
        db_drop_table($name, $table);
      }
      $schema = _field_sql_storage_schema($field);
      foreach ($schema as $name => $table) {
        db_create_table($name, $table);
      }
    }
    catch (Exception $e) {
      if (Database::getConnection()->supportsTransactionalDDL()) {
        $transaction->rollback();
      }
      else {
        // Recreate tables.
        $prior_schema = _field_sql_storage_schema($prior_field);
        foreach ($prior_schema as $name => $table) {
          if (!db_table_exists($name)) {
            db_create_table($name, $table);
          }
        }
      }
      throw $e;
    }
  }
  else {
    // There is data, so there are no column changes. Drop all the
    // prior indexes and create all the new ones, except for all the
    // priors that exist unchanged.
    $table = _field_sql_storage_tablename($prior_field);
    $revision_table = _field_sql_storage_revision_tablename($prior_field);

    $schema = $field->getSchema();
    $prior_schema = $prior_field->getSchema();

    foreach ($prior_schema['indexes'] as $name => $columns) {
      if (!isset($schema['indexes'][$name]) || $columns != $schema['indexes'][$name]) {
        $real_name = _field_sql_storage_indexname($field['field_name'], $name);
        db_drop_index($table, $real_name);
        db_drop_index($revision_table, $real_name);
      }
    }
    $table = _field_sql_storage_tablename($field);
    $revision_table = _field_sql_storage_revision_tablename($field);
    foreach ($schema['indexes'] as $name => $columns) {
      if (!isset($prior_schema['indexes'][$name]) || $columns != $prior_schema['indexes'][$name]) {
        $real_name = _field_sql_storage_indexname($field['field_name'], $name);
        $real_columns = array();
        foreach ($columns as $column_name) {
          // Indexes can be specified as either a column name or an array with
          // column name and length. Allow for either case.
          if (is_array($column_name)) {
            $real_columns[] = array(
              _field_sql_storage_columnname($field['field_name'], $column_name[0]),
              $column_name[1],
            );
          }
          else {
            $real_columns[] = _field_sql_storage_columnname($field['field_name'], $column_name);
          }
        }
        db_add_index($table, $real_name, $real_columns);
        db_add_index($revision_table, $real_name, $real_columns);
      }
    }
  }
  drupal_get_schema(NULL, TRUE);
}

/**
 * Implements hook_field_storage_delete_field().
 */
function field_sql_storage_field_storage_delete_field($field) {
  // Mark all data associated with the field for deletion.
  $field['deleted'] = FALSE;
  $table = _field_sql_storage_tablename($field);
  $revision_table = _field_sql_storage_revision_tablename($field);
  db_update($table)
    ->fields(array('deleted' => 1))
    ->execute();

  // Move the table to a unique name while the table contents are being deleted.
  $field['deleted'] = TRUE;
  $new_table = _field_sql_storage_tablename($field);
  $revision_new_table = _field_sql_storage_revision_tablename($field);
  db_rename_table($table, $new_table);
  db_rename_table($revision_table, $revision_new_table);
  drupal_get_schema(NULL, TRUE);
}

/**
 * Implements hook_field_storage_purge().
 *
 * This function deletes data from the database for a single field on
 * an entity.
 */
function field_sql_storage_field_storage_purge(EntityInterface $entity, $field, $instance) {
  $table_name = _field_sql_storage_tablename($field);
  $revision_name = _field_sql_storage_revision_tablename($field);
  db_delete($table_name)
    ->condition('entity_type', $entity->entityType())
    ->condition('entity_id', $entity->id())
    ->execute();
  db_delete($revision_name)
    ->condition('entity_type', $entity->entityType())
    ->condition('entity_id', $entity->id())
    ->execute();
}

/**
 * Implements hook_field_storage_delete_instance().
 *
 * This function simply marks for deletion all data associated with the field.
 */
function field_sql_storage_field_storage_delete_instance($instance) {
  $field = field_info_field($instance['field_name']);
  $table_name = _field_sql_storage_tablename($field);
  $revision_name = _field_sql_storage_revision_tablename($field);
  db_update($table_name)
    ->fields(array('deleted' => 1))
    ->condition('entity_type', $instance['entity_type'])
    ->condition('bundle', $instance['bundle'])
    ->execute();
  db_update($revision_name)
    ->fields(array('deleted' => 1))
    ->condition('entity_type', $instance['entity_type'])
    ->condition('bundle', $instance['bundle'])
    ->execute();
}

/**
 * Implements hook_field_storage_purge_field().
 *
 * All field data items and instances have already been purged, so all that is
 * left is to delete the table.
 */
function field_sql_storage_field_storage_purge_field($field) {
  $table_name = _field_sql_storage_tablename($field);
  $revision_name = _field_sql_storage_revision_tablename($field);
  db_drop_table($table_name);
  db_drop_table($revision_name);
}

/**
 * Implements hook_field_storage_details().
 */
function field_sql_storage_field_storage_details($field) {
  $details = array();
  if (!empty($field['columns'])) {
     // Add field columns.
    foreach ($field['columns'] as $column_name => $attributes) {
      $real_name = _field_sql_storage_columnname($field['field_name'], $column_name);
      $columns[$column_name] = $real_name;
    }
    return array(
      'sql' => array(
        FIELD_LOAD_CURRENT => array(
          _field_sql_storage_tablename($field) => $columns,
        ),
        FIELD_LOAD_REVISION => array(
          _field_sql_storage_revision_tablename($field) => $columns,
        ),
      ),
    );
  }
}
