<?php

/**
 * @file
 * Contains install and update functions for Views.
 */

/**
 * Implements hook_install().
 */
function views_install() {
  module_set_weight('views', 10);
}

/**
 * @addtogroup updates-8.0.0-beta
 * @{
 */

/**
 * Update views field plugins.
 */
function views_update_8001(&$sandbox) {
  $config_factory = \Drupal::configFactory();
  $ids = [];
  $message = NULL;
  $ago_formats = [
    'time ago',
    'time hence',
    'time span',
    'raw time ago',
    'raw time hence',
    'raw time span',
    'inverse time span',
  ];

  foreach ($config_factory->listAll('views.view.') as $view_config_name) {
    $view = $config_factory->getEditable($view_config_name);

    $displays = $view->get('display');

    foreach ($displays as $display_name => $display) {
      if (!empty($display['display_options']['fields'])) {
        foreach ($display['display_options']['fields'] as $field_name => $field) {
          if (isset($field['entity_type']) && $field['plugin_id'] === 'date') {
            $ids[] = $view->get('id');

            // Grab the settings we need to move to a different place in the
            // config schema.
            $date_format = !empty($field['date_format']) ? $field['date_format'] : 'medium';
            $custom_date_format = !empty($field['custom_date_format']) ? $field['custom_date_format'] : '';
            $timezone = !empty($field['timezone']) ? $field['timezone'] : '';

            // Save off the base part of the config path we are updating.
            $base = "display.$display_name.display_options.fields.$field_name";

            if (in_array($date_format, $ago_formats)) {
              // Update the field to use the Field API formatter.
              $view->set($base . '.plugin_id', 'field');
              $view->set($base . '.type', 'timestamp_ago');

              // Ensure the granularity is an integer, which is defined in the
              // field.formatter.settings.timestamp_ago schema.
              $granularity = is_numeric($custom_date_format) ? (int) $custom_date_format : 2;

              // Add the new settings.
              if ($date_format === 'time ago' || $date_format === 'time hence' || $date_format === 'time span') {
                $view->set($base . '.settings.future_format', '@interval hence');
                $view->set($base . '.settings.past_format', '@interval ago');
                $view->set($base . '.settings.granularity', $granularity);
              }
              elseif ($date_format === 'raw time ago' || $date_format === 'raw time hence') {
                $view->set($base . '.settings.future_format', '@interval');
                $view->set($base . '.settings.past_format', '@interval');
                $view->set($base . '.settings.granularity', $granularity);
              }
              elseif ($date_format === 'raw time span') {
                $view->set($base . '.settings.future_format', '@interval');
                $view->set($base . '.settings.past_format', '-@interval');
                $view->set($base . '.settings.granularity', $granularity);
              }
              elseif ($date_format === 'inverse time span') {
                $view->set($base . '.settings.future_format', '-@interval');
                $view->set($base . '.settings.past_format', '@interval');
                $view->set($base . '.settings.granularity', $granularity);
              }
            }
            else {
              // Update the field to use the Field API formatter.
              $view->set($base . '.plugin_id', 'field');
              $view->set($base . '.type', 'timestamp');

              // Add the new settings, and make sure everything is a string
              // to conform with the field.formatter.settings.timestamp schema.
              $view->set($base . '.settings.date_format', (string) $date_format);
              $view->set($base . '.settings.custom_date_format', (string) $custom_date_format);
              $view->set($base . '.settings.timezone', (string) $timezone);
            }

            // Remove the old settings.
            $view->clear($base . '.date_format');
            $view->clear($base . '.custom_date_format');
            $view->clear($base . '.timezone');
          }
        }
      }
    }

    $view->save(TRUE);
  }

  if (!empty($ids)) {
    $message = t('Updated field plugins for views: @ids', ['@ids' => implode(', ', array_unique($ids))]);
  }

  return $message;
}

/**
 * Update all views to re-generate the cacheability metadata.
 */
function views_update_8002(&$sandbox) {
  $config_factory = \Drupal::configFactory();

  // Remove 'cacheable' key from cache_metadata. See change record
  // https://www.drupal.org/node/2538352 for more explanation.
  foreach ($config_factory->listAll('views.view.') as $view_config_name) {
    $view = $config_factory->getEditable($view_config_name);
    // To update the cacheability metadata of an existing view we have to
    // recalculate it. Cacheability metadata is calculated per display bases so
    // we have to load each display. To load the each display we need
    // \Drupal\views\ViewExecutable. To load the ViewExecutable we need
    // \Drupal\views\ViewEntityInterface which can be loaded using views storage
    // controller.
    /*  @var \Drupal\views\ViewEntityInterface $view_storage */
    $view_storage = \Drupal::service('entity.manager')
      ->getStorage('view')
      ->load($view->get('id'));
    $view_executable = \Drupal::service('views.executable')
      ->get($view_storage);
    $displays = $view->get('display');
    foreach (array_keys($displays) as $display_id) {
      $view_executable->setDisplay($display_id);
      $display_plugin = $view_executable
        ->getDisplay();
      // Remove the old cacheability metadata so that we can recalculate.
      unset($display_plugin->display['cache_metadata']);
      $cache_metadata = $display_plugin->getCacheMetadata();
      $view->set("display.$display_id.cache_metadata", [
        'contexts' => $cache_metadata->getCacheContexts(),
        'max_age'=> $cache_metadata->getCacheMaxAge(),
        'tags' => $cache_metadata->getCacheTags(),
      ]);
    }
    $view->save(TRUE);
  }

  return t('Updated cacheability metadata of all the views.');

}

/**
 * @} End of "addtogroup updates-8.0.0-beta".
 */
